<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="sounding.css">
<title></title>
<body>
<div id="container">
<div id="mainbox">
	<div id="checks_wrapper">
		<div id="checks">
			<label for="parcel_check"><input id="parcel_check" type="checkbox" checked="checked">Parcel Temperature</input></label>
			<label for="parcelmix_check"><input id="parcelmix_check" type="checkbox" checked="checked">Mixed Parcel Temperature</input></label>
			<label for="tvc_check"><input id="tvc_check" type="checkbox" checked="checked">Virtual Temperature</input></label>
			<label for="twc_check"><input id="twc_check" type="checkbox" checked="checked">Wet Bulb Temperature</input></label>
		</div>
		<div id="upload_wrapper">
			<label id="fileUpload" for="input-file">Upload File:</label>
			<input type="file" id="input-file">
		</div>
		<div id="editData">
			<button id="editButton" onClick="tableVis()">Show Data Table</button>
		</div>
		<div id="resets">
			<p>Preset Soundings:
				<select id="allstar_sounding">
					<option disabled>&#9473; Defaults &#9473;</option>
					<option value="data_TOP.json" default>Default Sounding</option>
					<option value="data_SkewT.json">Flash Sounding</option>
					<option disabled>&#9473; Thunderstorms & Tornadoes &#9473;</option>
						<option value="./All-Star-Soundings/BMX_2011427_18.html">Tornado Outbreak (BMX)</option>
						<option value="./All-Star-Soundings/BMX_2011428_00.html">Tornado Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/TOP_200354_12.html'>Tornado Outbreak (TOP)</option>
						<option value='./All-Star-Soundings/TOP_200354_18.html'>Tornado Outbreak (TOP)</option>
						<option value='./All-Star-Soundings/TOP_200355_00.html'>Tornado Outbreak -- Post Dryline (TOP)</option>
						<option value='./All-Star-Soundings/OUN_200358_12.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_200358_18.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_200359_00.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/TOP_2004530_00.html'>NE/KS/OK Tornadoes (TOP)</option>
						<option value='./All-Star-Soundings/OUN_2004530_00.html'>NE/KS/OK Tornadoes (OUN)</option>
						<option value='./All-Star-Soundings/BMX_2011427_18.html'>Severe Weather Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/BMX_2011428_00.html'>Severe Weather Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/JAN_2011427_18.html'>Severe Weather Outbreak (JAN)</option>
						<option value='./All-Star-Soundings/OUN_2011524_12.html'>Severe Weather Outbreak (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2011524_18.html'>Severe Weather Outbreak (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013520_12.html'>Moore, OK EF5 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013520_18.html'>Moore, OK EF5 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013531_12.html'>El Reno, OK EF3 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/FGZ_2017820_00.html'>Dry Microburst (FGZ)</option>
						<option value='./All-Star-Soundings/OUN_2015615_00.html'>Wet Microburst (OUN)</option>
						<option value='./All-Star-Soundings/IAD_2012630_00.html'>Derecho (IAD)</option>
					<option disabled>&#9473; Hurricanes &#9473;</option>
						<option value='./All-Star-Soundings/EYW_2004813_00.html'>Hurricane Charley (EYW)</option>
						<option value='./All-Star-Soundings/EYW_2004813_12.html'>Hurricane Charley (EYW)</option>
						<option value='./All-Star-Soundings/TBW_2004813_18.html'>Hurricane Charley (TBW)</option>
						<option value='./All-Star-Soundings/TBW_2004814_00.html'>Hurricane Charley (TBW)</option>
						<option value='./All-Star-Soundings/CRP_2003716_00.html'>Hurricane Claudette (Near Landfall; CRP)</option>
						<option value='./All-Star-Soundings/DRT_2003716_00.html'>Hurricane Claudette (Inland Dry Environment; DRT)</option>
						<option value='./All-Star-Soundings/DRT_2003716_06.html'>Hurricane Claudette (Inland Moistening Environment; DRT)</option>
						<option value='./All-Star-Soundings/DRT_2003716_12.html'>Hurricane Claudette (Inland over DRT; DRT)</option>
						<option value='./All-Star-Soundings/76595_2002923_12.html'>Hurricane Isidore (76595)</option>
						<option value='./All-Star-Soundings/MMMD_2002922_12.html'>Hurricane Isidore (MMMD)</option>
						<option value='./All-Star-Soundings/LIX_2005827_06.html'>Hurricane Katrina (LIX)</option>
						<option value='./All-Star-Soundings/LZK_2005830_00.html'>Remnants of Hurricane Katrina (LZK)</option>
						<option value='./All-Star-Soundings/TXKF_20141018_12.html'>Hurricane Gonzalo (direct hit on Bermuda; TXKF)</option>
						<option value='./All-Star-Soundings/JAX_2016108_00.json'>Hurricane Matthew (JAX)</option>
						<option value='./All-Star-Soundings/CRP_2017826_00.html'>Hurricane Harvey (Near Landfall; CRP)</option>
						<option value='./All-Star-Soundings/EYW_2017910_00.html'>Hurricane Irma (12 hrs prior to landfall; EYW))</option>
						<option value='./All-Star-Soundings/TBW_2017911_00.html'>Hurricane Irma (12 hrs post landfalll TBW)</option>
					<option disabled>&#9473; Heavy Snow &#9473;</option>
						<option value="./All-Star-Soundings/ABR_20051129_00.html">Heavy Snow (ABR)</option>
						<option value='./All-Star-Soundings/BUF_20011224_12.html'>Heavy Lake Effect Snow (BUF)</option>
						<option value='./All-Star-Soundings/BUF_20011225_00.html'>Heavy Lake Effect Snow (BUF)</option>
						<option value='./All-Star-Soundings/OUN_20021223_18.html'>Heavy Snow/Thundersnow</option>
						<option value='./All-Star-Soundings/FWD_2004213_12.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004214_00.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004214_12.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004215_00.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/ABR_20051129_00.html'>Winter Storm</option>
						<option value='./All-Star-Soundings/OKX_2006212_06.html'>Historic Blizzard</option>
						<option value='./All-Star-Soundings/CHH_2006212_06.html'>Historic Blizzard</option>
						<option value='./All-Star-Soundings/LBF_2006321_00.html'>Great Plains Snowstorm</option>
						<option value='./All-Star-Soundings/OAX_2006321_00.html'>Great Plains Snowstorm</option>
						<option value='./All-Star-Soundings/BUF_20131212_00.html'>Heavy Lake Effect Snow</option>
						<option value='./All-Star-Soundings/CHH_2015127_12.html'>Boston Blizzard</option>
						<option value='./All-Star-Soundings/BUF_20141119_00.html'>Heavy Lake Effect Snow</option>
						<option value='./All-Star-Soundings/GYX_2015128_00.html'>Blizzard</option>
						<option value='./All-Star-Soundings/TFX_2019929_12.html'>4 Feet of Snow</option>
					<option disabled>&#9473; Heavy Rain/Flooding &#9473;</option>
						<option value='./All-Star-Soundings/FWD_2004728_00.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FWD_2004728_12.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FWD_2004729_00.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FFC_2009920_12.html'>Atlanta Flash Flood</option>
						<option value='./All-Star-Soundings/OUN_2010614_00.html'>Oklahoma City Flash Flood</option>
						<option value='./All-Star-Soundings/OUN_2010614_12.html'>Oklahoma City Flash Flood</option>
						<option value='./All-Star-Soundings/OKX_2014813_12.html'>Historic Flooding on Long Island</option>
						<option value='./All-Star-Soundings/DNR_2013912_12.html'>Historic Flooding along Front Range of Colorado</option>
						<option value='./All-Star-Soundings/DNR_2013913_12.html'>Historic Flooding along Front Range of Colorado</option>
					<option disabled>&#9473; Precipitation Typing &#9473;</option>
						<option value='./All-Star-Soundings/FWD_20001213_12.html'>Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/OUN_20001213_12.html'>Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/FWD_20001226_00.html'>Rain/Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/OUN_20001226_00.html'>Rain/Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/GSO_200821_12.html'>Cold Air Damming</option>
					<option disabled>&#9473; Heat Wave &#9473;</option>
						<option value='./All-Star-Soundings/OUN_2003721_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/OUN_201183_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/FWD_201183_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/DVN_1995714_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/ILX_1995714_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/NKX_201877_00.html'>Heat Wave</option>
					<option disabled>&#9473; Cold Wave &#9473;</option>
						<option value='./All-Star-Soundings/PABR_2002110_00.html'>Large Inversion/Low Tropopause</option>
						<option value='./All-Star-Soundings/OAX_201417_12.html'>Arctic Cold Blast (Record-setting Surface High)</option>
						<option value='./All-Star-Soundings/UIL_201427_12.html'>Seattle Record Cold</option>
						<option value='./All-Star-Soundings/MPX_199622_12.html'>Frigid Cold</option>
						<option value='./All-Star-Soundings/ABR_201416_00.json'>Brutal Cold</option>
					<option disabled>&#9473; Wildfire &#9473;</option>
						<option value='./All-Star-Soundings/MFR_2018727_00.html'>Carr Wildfire</option>		
				</select>
			<button id="default" onClick="loadSounding()" value="default">Load Sounding</button>
			</p>
		</div>
	</div>
</div>
<div id="hodobox"></div>
<div id="editTableWrap"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="jsfunctions.js"></script>
<script type="text/javascript">

$(document).ready( function() {
	$(window).keydown(function(event){
		if(event.keyCode == 13) {
		event.preventDefault();
		return false;
		}
  	});

	$("input:checkbox").on("change", function() {
		var checkbox_id = $(this).prop("id");
		var className = checkbox_id.split("_",1).toString();
		$("." + className + ".member").toggle();
		$("." + className + ".focus").css('visibility', $('.' +className + '.focus').css('visibility') == 'hidden' ? 'visible' : 'hidden');
		if(className == "twc") {
			$(".wbztext, .wbz_rectline").css('visibility', $(".wbztext, .wbz_rectline").css('visibility') == 'hidden' ? 'visible' : 'hidden');
			drawSkew();
			drawText();
			tabulate();
		} else if (className == "tvc") {
			drawSkew();
			drawText();
			tabulate();
		} else if (className == "parcel") {
			$(".lcltext, .lcl, .lfctext, .lfc, .eltext, .el").css('visibility', $(".lcltext, .lcl, .lfctext, .lfc, .eltext, .el").css('visibility') == 'hidden' ? 'visible' : 'hidden');
			drawSkew();
			drawText();
			tabulate();
		} else if (className == "parcelmix") {
			$(".lclmixtext, .lclmix, .lfcmixtext, .lfcmix, .elmixtext, .elmix").css('visibility', $(".lclmixtext, .lclmix, .lfcmixtext, .lfcmix, .elmixtext, .elmix").css('visibility') == 'hidden' ? 'visible' : 'hidden');
			drawSkew();
			drawText();
			tabulate();
		} else {
		}
	})

});

var lat, long;
var columns = ['press', 'temp', 'dwpt', 'wdir', 'wspd'];

function tableVis () {
	$("#editTableWrap").toggle();
	if ($("#editTableWrap").is(":visible")) {
		$("#editButton").text("Hide Data Table");
	} else {
		$("#editButton").text("Show Data Table");
	}
	tabulate();
}

function tabulate() {
	d3.select("#editTableWrap").html("");
	var table = d3.select('#editTableWrap').append('table').attr("id","editTable");
	var thead = table.append('thead');
	var	tbody = table.append('tbody');

	// append the header row
	thead.append('tr')
	  .selectAll('th')
	  .data(columns).enter()
	  .append('th')
	    .text(function (column) { return column; });

	// create a row for each object in the data
	var rows = tbody.selectAll('tr')
	  .data(tlinetest[0][0])
	  .enter()
	  .append('tr');

	// create a cell in each row for each column
	var cells = rows.selectAll('td')
	  .data(function (row) {
	    return columns.map(function (column) {
	      return {column: column, value: row[column]};
	    });
	  })
	  .enter()
	  .append('td')
		  .attr("contenteditable", "true")
		  .attr("class", "edit")
		  .text(function (d) { return d.value; });

	rows.selectAll(":first-child").attr("contenteditable", "false");

	$("[contenteditable=true]").on("input", function() {
		var row = $(this).parent().children();
		var i = $("tr:not(:first)").index($(this).parent());
		var j = $(this).parent().children("td").index(this);
   		update(row, i, j);
	});

  return table;
}

function update(r, i, j) {
	var here = $("#editTable tr:not(:first)").eq(i).children("td").eq(j);
	console.log(here);
	console.log(i,j);

	var inputText = r.eq(j).text().trim();

	var signs = /^[-+.]?[.]?$/;
	var numbers = /^[-+]?[0-9]*\.?[0-9]+$/;

	if (j%4 == 1 || j%4 == 2) {
		if (inputText.match(signs)) {
			console.log("Matching signs");
			return false
		}
	}

	if (inputText == "") {
		console.log("Matching no text");
		here.addClass("blank");
		return false
	} else if (inputText.match(numbers)) {
		console.log("Matching numbers");
		if (j == 1) {
			tlinetest[0][0][i].temp = parseFloat(inputText);
			if (tlinetest[0][0][i].temp < tlinetest[0][0][i].dwpt) {
				console.log("Testing: temp is less than dewpoint");
				console.log("Temp: " + tlinetest[0][0][i].temp);
				console.log("Dewpoint: " + tlinetest[0][0][i].dwpt);
				// Send error message to user to correct temp and dwpt
				here.addClass("blank");
				here.next().addClass("blank");
				return false
			} else {
				console.log("Testing: temp is greater than dewpoint");
				console.log("Temp: " + tlinetest[0][0][i].temp);
				console.log("Dewpoint: " + tlinetest[0][0][i].dwpt);
				here.removeClass("blank");
				here.next().removeClass("blank");
			}
		} else if (j == 2) {
			tlinetest[0][0][i].dwpt = parseFloat(inputText);
			if (tlinetest[0][0][i].dwpt > tlinetest[0][0][i].temp) {
				// Send error message to user to correct temp and dwpt
				console.log("Testing: dewpoint temp is greater than temp");
				console.log("Temp: " + tlinetest[0][0][i].temp);
				console.log("Dewpoint: " + tlinetest[0][0][i].dwpt);
				here.addClass("blank");
				here.prev().addClass("blank");
				return false
			} else {
				console.log("Testing: dewpoint temp is less than temp");
				console.log("Temp: " + tlinetest[0][0][i].temp);
				console.log("Dewpoint: " + tlinetest[0][0][i].dwpt);
				here.removeClass("blank");
				here.prev().removeClass("blank");
			}
		} else if (j == 3) {
			if (inputText.match(/^\d*\.?\d+$/)) {
				if (parseFloat(inputText) > 360 || parseFloat(inputText) < 0 ) {
					var howLarge = parseFloat(inputText)/360;
					if (howLarge < 1 && howLarge > 0) {
						var direct = parseFloat(inputText);
					} else if (howLarge < 0 && howLarge > -1) {
						var direct = parseFloat(inputText) + 360;
					} else if (Math.abs(howLarge) >= 1) {
						var multiplier = Math.floor(howLarge);
						var direct = parseFloat(inputText) - 360*multiplier;
					}
					here.text(direct);
				}
				tlinetest[0][0][i].wdir = parseFloat(inputText);
			} else {
				here.text(tlinetest[0][0][i].wdir);
				return false;
			}
		} else if (j == 4) {
			if (inputText.match(/^\d*\.?\d+$/)) {
				tlinetest[0][0][i].wspd = parseFloat(inputText);
				tlinetest[0][0][i].wspdround = Math.round((parseFloat(inputText)/5))*5;
			} else {
				here.text(tlinetest[0][0][i].wspd);
				return false;
			}

		}
	} else {
		console.log("Matching else");
		if (j == 1) {
			here.text(tlinetest[0][0][i].temp);
		} else if (j == 2) {
			here.text(tlinetest[0][0][i].dwpt);
		} else if (j == 3) {
			here.text(tlinetest[0][0][i].wdir);
		} else if (j == 4) {
			here.text(tlinetest[0][0][i].wspd);	
		}
		return false;
	}
	here.removeClass("blank");
	drawSkew();
	drawText();
}

function loadSounding () {
	var soundingFile = $('#allstar_sounding').children('option:selected').val();
	$(".focusgroup").empty();
	title = "";
	if (soundingFile.includes(".html")) {
		getHTMLSounding(soundingFile);
	} else if (soundingFile.includes(".json")) {
		dataParse(soundingFile);
	}
	
}

var sounding = '';

$("input[type='file']").on("change", function () {
	const reader = new FileReader();
	reader.readAsText(document.querySelector('input[type="file"]').files[0]);
	console.log(reader.result);
	reader.onload = () => storeResults(reader.result);
});

function getHTMLSounding(filename) {
	var dataRead = fetch(filename)
		.then(response => response.blob())
		.then(function(myBlob) {
			myBlob.text().then(text => storeResults(text));
		});
}

function storeResults(result) {
	sounding = result;
	jsonObj = convertFiletoJSON(sounding);
	dataParse();
}

//some constants from meted.ucar.edu/awips/validate
var R = 287.04; // J/Kg K--gas constant
var Cp = 1004; // J/Kg K--specific heat at constant pressure
var g = 9.80665;
var c5 = -0.37329638;
var c6 = 41.178204;
var c7 = 0.0015945203;
var c10 = 0.1419709;
var c11 = 20.746475;
var c12 = 6672.5713;
var c13 = .000036336427;
var T0 = 288.15;
var P0 = 1013.25;

var jsonObj;
var sdata = new Array();
var data_arr = [];
var filtered = [];
var title = '';
var labels = [];

var ppcl = 0;//pressure for parcel to be lifted
var tpcl = 0;//temp for parcel to be lifted (C)
var tdpcl = 0; //dewpoint for parcel to be lifted
var plcl = 0; //pres at LCL
var tlcl = 0; //temp at LCL
var plfc = -1; //pressure at LFC
var tlfc = 0; //temp at LFC 
var pel = 0; //pressure at EL
var tel = 0; //tempC at EL
var thetae_lcl = 0;//theta-e at LCL
var pccl = 0; //pres at ccl - set in calcCCL()
var tccl = 0; //temp at ccl - set in calcCCL(), used by calcConvTemp()
var p_pcl100 = 0;//_parent.capeMC.ppcl
var t_pcl100 = 0;//_parent.capeMC.tpcl
var td_pcl100 = 0;//_parent.capeMC.tdpcl
var parcel_temp = 0;
var parcel_temp_array = new Array();
var pcl_t_arr = new Array();
var ml_pcl_t_arr = new Array();
var parcel_flag = 0;
var cin_parcelT = 0;
var cin_parcelT_array = new Array();
var cin_parcelT_below_LCL_array = new Array();
var pcl_cin_t_arr = new Array();
var pcl_cin_t_below_LCL_arr = new Array();
var bl_depth = 100;

var t500 = 0; //temp(C) at 500 mb
var ws500 = 0; //windspeed at 500 mb
var wd500 = 0; //wind direction at 500 mb
var t700 = 0; //temp at 700(C) mb
var td700 = 0; //dewpoint at 700(C)
var t850 = 0; //temp(C) at 850 mb
var td850 = 0; //dewpoint at 850(C)
var ws850 = 0; //windspeed at 850 mb
var wd850 = 0; //wind direction at 850 mb
var t1000 = 0; //temp(C) at 1000 mb
var td1000 = 0; //dewpoint at 1000(C)
var ws1000 = 0; //windspeed at 1000 mb
var wd1000 = 0; //wind direction at 1000 mb
var flag_1000 = 0;
var flag_850 = 0;
var flag_700 = 0;
var flag_500 = 0;
var tk = 0; //temp (K)
var tdk = 0; //dewpoint (K)
var p_sfc = 0;
var t_sfc = 0;
var td_sfc = 0;

var m = [30, 40, 20, 35],
    width = 700 - m[1] - m[3],
    height = 700 - m[0] - m[2];

var d2r = (Math.PI/180);
var tempSkew = 55;
var tan = Math.tan(tempSkew*d2r),
    basep = 1050,
    topp = 100,
    plines = [1000,925,850,700,600,500,400,300,200,100]
    pticks = [950,900,800,750,650,600,550,450,400,350,250,150];
	barbsize = 25;

// Scales and axes. Note the inverted domain for the y-scale: bigger is up!
var x = d3.scale.linear().range([0, width]).domain([-45,50]),
    y = d3.scale.log().range([0, height]).domain([topp, basep])
    r = d3.scale.linear().range([0,300]).domain([0,150]),
    y2 = d3.scale.linear(),
    xAxis = d3.svg.axis().scale(x).tickSize(0,0).ticks(10).orient("bottom"),
    yAxis = d3.svg.axis().scale(y).tickSize(0,0).tickValues(plines)
              .tickFormat(d3.format(".0d")).orient("left")
	yAxis2 = d3.svg.axis().scale(y).tickSize(5,0).tickValues(pticks).orient("right"); // just for ticks

// various path generators
var line = d3.svg.line()
    .interpolate("linear")
    .x(function(d,i) { return x(d.temp) + (y(basep)-y(d.press))/tan; })
    .y(function(d,i) { return y(d.press); });
    
var line2 = d3.svg.line()
    .interpolate("linear")
    .x(function(d,i) { return x(d.dwpt) + (y(basep)-y(d.press))/tan; })
    .y(function(d,i) { return y(d.press); });

var hodoline = d3.svg.line.radial()
    .radius(function(d) { return r(d.wspd); })
	.angle(function(d) { return (d.wdir+180)*(Math.PI/180); });
    
// bisector function for tooltips    
var bisectTemp = d3.bisector(function(d) { return d.press; }).left;

// create svg container for sounding
var svg = d3.select("div#mainbox").insert("svg", ":first-child")
      .attr("width", width + m[1] + m[3])
	  .attr("height", height + m[0] + m[2])
	  .attr("id","box")
    .append("g")
		  .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
    
var titleText = d3.select("div#mainbox svg").append("svg").attr("class", "title").attr("width", 700).attr("height", 40).append("text").attr("class", "titleText");      

// create svg container for hodograph
var svghodo = d3.select("div#hodobox").append("svg")
      .attr("width", 360)
      .attr("height", 300)
	  .append("g")
	  .attr("class","hodosvg")
	  .attr("transform", "translate(150,150)");
	  
	hodofocus = svghodo.append("g")
		.attr("class","hodogroup")
		.append("line")
		.attr("class","focus hodarrow")
		.attr("x1", "0")
		.attr("y1", "0")
		.attr("stroke-width","2")
		.attr("marker-end","url(#arrowhead)")
		.style("display","none");

	d3.select(".hodogroup")
		.append("circle")
		.attr("r", "6px")
		.attr("fill", "cyan")
		.attr("stroke", "black")
		.attr("opacity",".6")
		.style("display", "none")
		.attr("class", "focus hod");
      
var svgtext = d3.select("div#hodobox").append("svg").attr("class", "indices").attr("width", 360).attr("height", 400)
			.append("g").attr("transform", "translate(0,50)");      


makeBarbTemplates();
drawBackground();
drawTextLabels();

var skewtgroup = svg.append("g").attr("class", "skewt"); // put skewt lines in this group
var barbgroup  = svg.append("g").attr("class", "windbarb"); // put barbs in this group
var hodogroup = svghodo.append("g").attr("class", "hodo"); // put hodo stuff in this group
var membergroup = skewtgroup.append("g").attr("class", "membergroup"); // put member lines in this group
var labelgroup = skewtgroup.append("g").attr("class", "labelgroup"); // put labels in this group
var focusgroup = skewtgroup.append("g").attr("class", "focusgroup"); // put focus dots in this group

var hodobarbstest = [];

dataParse('data_TOP.json'); // 2003 Jun 24 00Z
//dataParse('data_LBF.json'); // 2003 Jun 23 00Z
//dataParse('data_TBW.json'); // 2019 Nov 26 00Z
//dataParse('data_ILX.json'); // 2013 Nov 17 15Z
//dataParse('data_DNR.json'); // 2019 Nov 26 00Z
//dataParse('data_SkewT.json');// Interactive Skew-T

function dataParse(fileName) {

	hodobarbstest = [], tlinetest = [], interpdots = [], barbstest = [], flattened = [];
	var hr=0;
	var temp = [], temp2 = [], temp3 = [];
	var mem = 0;
	
	if (fileName) {	
		d3.json(fileName, function(err, json) {
				parseDataNew(json);
	
	       		parsedCSV = alldata[mem][hr].filter(function(d) { return (d.temp > -1000 && d.dwpt > -1000); });
	       		barbs = parsedCSV.filter(function(d) { return (d.wdir >= 0 && d.wspd >= 0 && d.press >= topp); });
	       		hodobarbs = barbs.filter(function(d) { return (d.press >= 200); });
	        	interpdot = interpobjects[hr + 49*mem];
	
		        temp.push(hodobarbs);
	       		temp2.push(parsedCSV);
	        	temp3.push(barbs);
	        	interpdots.push(interpdot);
	        	hodobarbstest.push(temp);
	        	tlinetest.push(temp2);
	        	barbstest.push(temp3);
	
		    // need this for dots for some reason
		    mouseoverdata = tlinetest[0][0].slice(0).reverse();
			flattened = interpdots.reduce(function(a,b) { return a.concat(b); });
			drawSkew();
			drawText();
			drawToolTips();
			tabulate();
		});
	} else {
		alldata=[[sdata]];
	       	parsedCSV = alldata[mem][hr].filter(function(d) { return (d.temp > -1000 && d.dwpt > -1000); });
	       	barbs = parsedCSV.filter(function(d) { return (d.wdir >= 0 && d.wspd >= 0 && d.press >= topp); });
	       	hodobarbs = barbs.filter(function(d) { return (d.press >= 200); });


		var hAGL;
		var test = [];
		interpobjects = [];
		test.push(parsedCSV[0]);
		for (j=1; j< requestedLevels.length; j++) {
			hAGL = requestedLevels[j]*1000+parsedCSV[0].hght;
			for (i=1; i<parsedCSV.length; i++) {
				if (parsedCSV[i].hght > hAGL) {
					var interp = d3.interpolateObject(parsedCSV[i-1],parsedCSV[i]);
    		    			var half = interp(1-(hAGL - parsedCSV[i].hght)/(parsedCSV[i-1].hght - parsedCSV[i].hght));
    		    			test.push(half);
					break;
				}
			};
		};

		interpobjects.push(test);

	        interpdot = interpobjects[hr + 49*mem];
	
		temp.push(hodobarbs);
	       	temp2.push(parsedCSV);
	        temp3.push(barbs);
	        interpdots.push(interpdot);
	        hodobarbstest.push(temp);
	        tlinetest.push(temp2);
	        barbstest.push(temp3);
	
	// need this for dots for some reason
		mouseoverdata = tlinetest[0][0].slice(0).reverse();
		flattened = interpdots.reduce(function(a,b) { return a.concat(b); });

		for (i=0; i<tlinetest[0][0].length ; i++) {
			if (i==0) {
				var height0 = tlinetest[0][0][0].hght;
			}
			tlinetest[0][0][i].hghtagl = tlinetest[0][0][i].hght - height0;
		}

		d3.selectAll("g.focusgroup > *").remove();
		d3.selectAll("g.membergroup > *").remove();
		d3.selectAll("g.labelgroup > *").remove();
		d3.selectAll("g.windbarb > *").remove();
		d3.selectAll("g.hodo > *").remove();
		makeBarbTemplates();
		drawSkew();
		drawText();
		drawToolTips();
		tabulate();
	}
}

function parseDataNew(json) {
    requestedLevels = [0,1,3,6,9]; // levels in km agl
    interpobjects = [];
    alldata = json['tmpc'].map(function(c,k) {
    	return c.map(function(d,i) {
        	var obj = d.map(function(e,j) {
    	    	return {
    	    	    press: +json.pres[k][i][j],
    		     	hght: +json.hght[k][i][j],
    	            temp: +json.tmpc[k][i][j],
    	            dwpt: +json.dwpt[k][i][j],
    	            wdir: +json.wdir[k][i][j],
    	            wspd: +json.wspd[k][i][j],
    	            hghtagl: +json.hght[k][i][j] - +json.hght[k][i][0],
    	            wspdround: Math.round((json.wspd[k][i][j])/5) * 5
		     }
        	});
        	
        	// interpolate to given heights for each sounding
    		var test = requestedLevels.map(function(d) {
    			if (d == 0) { return obj[0]; }
    			d = 1000*d+obj[0].hght; // want height AGL
    		    for (i=0; i<=obj.length; i++) {
    		        if (obj[i].hght > d) { var closeindex = i; break; } // since hghts increase monotonically
    		    }
    		    var interp = d3.interpolateObject(obj[i-1],obj[i]); // interp btw two levels
    		    var half = interp(1-(d - obj[i].hght)/(obj[i-1].hght - obj[i].hght));
    		    return half
    		});
    		interpobjects.push(test);
    	    return obj;
    	});
    });
	return alldata;
}
       
function makeBarbTemplates() {
    var speeds = d3.range(5,205,5);
	barbdef = svg.append('defs')

/*	barbdef.append("g")
		.attr("id","rotateRect")
	
	d3.select("#rotateRect")
		.append("rect").attr("width", "35").attr("height", "15");
	d3.select("#rotateRect")
		.append("line").attr("x1", "0").attr("x2", "10").attr("y1", "7.5").attr("y2","7.5").attr("transform","translate(35,0)");
	d3.select("#rotateRect")
		.append("circle").attr("r","4").attr("transform","translate(45,7.5)"); */

    speeds.forEach(function(d) {
    	var thisbarb = barbdef.append('g').attr('id', 'barb'+d);
    	
    	var flags = Math.floor(d/50);
        var pennants = Math.floor((d - flags*50)/10);
        var halfpennants = Math.floor((d - flags*50 - pennants*10)/5);
        var px = barbsize;
        	    
		// Draw wind barb stems
		thisbarb.append("line").attr("class", "stem").attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", barbsize);
     
    	// Draw wind barb flags and pennants for each stem
	    for (i=0; i<flags; i++) {
     		thisbarb.append("polyline")
                .attr("points", "0,"+px+" -10,"+(px)+" 0,"+(px-4))
     		    .attr("class", "flag");
     		 px -= 7;
     	}
	    // Draw pennants on each barb
	    for (i=0; i<pennants; i++) {
    	    thisbarb.append("line")
     		    .attr("x1", 0)
     		    .attr("x2", -10)
     		    .attr("y1", px)
     		    .attr("y2", px+4)
     		 px -= 3;
     	}
     	// Draw half-pennants on each barb
        for (i=0; i<halfpennants; i++) {
    	    thisbarb.append("line")
     		    .attr("x1", 0)
     		    .attr("x2", -5)
     		    .attr("y1", px)
     		    .attr("y2", px+2)
     		px -= 3;
     	}
	});
	
	var arrows = barbdef.append("marker")
		.attr("id","arrowhead")
		.attr("markerWidth","5")
		.attr("markerHeight","5")
		.attr("refX","5")
		.attr("refY","2.5")
		.attr("orient","auto")
		.append("polygon")
		.attr("points","0 0, 5 2.5, 0 5")
		.attr("fill","#777");
}

function drawSkew() {
	$(".member, .hododot, .hodoline, .titleText, .windbarb > *, .label").remove();
    for (var i=0; i<tlinetest[0][0].length; i+=1) {
        var tw = calcWetbulb(tlinetest[0][0][i].press, tlinetest[0][0][i].temp, tlinetest[0][0][i].dwpt);
	 	tlinetest[0][0][i].twc = tw;
        var svp = calcVaporPressure(tlinetest[0][0][i].temp);
	 	tlinetest[0][0][i].es = svp;
        var vp = calcVaporPressure(tlinetest[0][0][i].dwpt);
	 	tlinetest[0][0][i].e = vp;
        var mixr = calcMixingRatio(tlinetest[0][0][i].e, tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].mr = mixr;
	 	rh=calcRelHumidity(tlinetest[0][0][i].e, tlinetest[0][0][i].es);
	 	tlinetest[0][0][i].relh = rh;
	 	tv=calcVirtualtemperature(tlinetest[0][0][i].temp,tlinetest[0][0][i].mr);
	 	tlinetest[0][0][i].tv = tv;
	 	sh=calcSpecHumidity(tlinetest[0][0][i].e, tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].sh = sh;
	 	pT=calcTheta(tlinetest[0][0][i].press, tlinetest[0][0][i].temp);
	 	tlinetest[0][0][i].theta = pT;
	 	epT=calcThetaE(tlinetest[0][0][i].press, tlinetest[0][0][i].temp, tlinetest[0][0][i].dwpt );
	 	tlinetest[0][0][i].thetaE = epT;
	 	z = calcZ(tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].Z = z;
    }

	var pw_total = calcPrecipWater();
	tlinetest[0][0][0].pw = pw_total;

        wb0_pres = calcWetbulbZero();
	tlinetest[0][0][0].wbz = wb0_pres;

	frz_lvl=calcFreezeLevel();
	tlinetest[0][0][0].frzl = frz_lvl;

	thk = calcThick();
	tlinetest[0][0][0].thick = thk;

	for (i=0; i<tlinetest[0][0].length-1; i++) {
		if (tlinetest[0][0][i].press == 1000) {
			t1000 = tlinetest[0][0][i].temp;
			td1000 = tlinetest[0][0][i].dwpt;
			ws1000 = tlinetest[0][0][i].wspd;
			wd1000 = tlinetest[0][0][i].wdir;
			flag_1000 = 1;
		} else if (tlinetest[0][0][i].press < 1000 && flag_1000 == 0) {
			if (i == 0) {
				t1000 = tlinetest[0][0][i].temp;
				td1000 = tlinetest[0][0][i].dwpt;
				ws1000 = tlinetest[0][0][i].wspd;
				wd1000 = tlinetest[0][0][i].wdir;
				flag_1000 = 1;
			} else {
				t1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
				td1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
				ws1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
				wd1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
				flag_1000 = 1;
			}
		} else if (tlinetest[0][0][i].press == 850) {
			t850 = tlinetest[0][0][i].temp;
			td850 = tlinetest[0][0][i].dwpt;
			ws850 = tlinetest[0][0][i].wspd;
			wd850 = tlinetest[0][0][i].wdir;
			flag_850 = 1;
		} else if (tlinetest[0][0][i].press < 850 && flag_850 == 0) {
			t850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			td850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
			ws850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
			wd850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
			flag_850 = 1;
		} else if (tlinetest[0][0][i].press == 700) {
			t700 = tlinetest[0][0][i].temp;
			td700 = tlinetest[0][0][i].dwpt;
			flag_700 = 1;
		} else if (tlinetest[0][0][i].press < 700 && flag_700 == 0) {
			t700 = interpVal(700, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			td700 = interpVal(700, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
			flag_700 = 1;

		} else if (tlinetest[0][0][i].press == 500) {
			t500 = tlinetest[0][0][i].temp;
			ws500 = tlinetest[0][0][i].wspd;
			wd500 = tlinetest[0][0][i].wdir;
			flag_500 = 1;
		} else if (tlinetest[0][0][i].press < 500 && flag_500 == 0) {
			t500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			ws500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
			wd500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
			flag_500 = 1;
		} else {
		}
	}

	mixed_parcel = getParcelVals();
	p_pcl100 = mixed_parcel[0];
	t_pcl100 = mixed_parcel[1];
	td_pcl100 = mixed_parcel[2];
	tlinetest[0][0][0].mixParcelP = p_pcl100;
	tlinetest[0][0][0].mixParcelT = t_pcl100;
	tlinetest[0][0][0].mixParcelTd = td_pcl100;

	var pCCL = calcCCL();
	tlinetest[0][0][0].CCL = pCCL;

	var conv_temp = calcConvTemp();
	tlinetest[0][0][0].tc = conv_temp;

	tt=calcTT();//total totals
	tlinetest[0][0][0].TT = tt;

	ki=calcKI();//K-index
	tlinetest[0][0][0].KI = ki;

	sweat=calcSWEAT();
	tlinetest[0][0][0].SWEAT = sweat;

        lclData = calcLCL(tlinetest[0][0][0].press,tlinetest[0][0][0].temp,tlinetest[0][0][0].dwpt);
        plcl = lclData[0];
        tlcl = lclData[1];
        zlcl = lclData[2];
	tlinetest[0][0][0].lclP = plcl;
	tlinetest[0][0][0].lclT = tlcl;
	tlinetest[0][0][0].lclZ = zlcl;

	capeBounds = findLFCandEL("SB");
	plfc = capeBounds[0];
	tlfc = capeBounds[1];
	zlfc = capeBounds[2];
	pel = capeBounds[3];
	tel = capeBounds[4];
	zel = capeBounds[5];
	tlinetest[0][0][0].lfcP = plfc;
	tlinetest[0][0][0].lfcT = tlfc;
	tlinetest[0][0][0].lfcZ = zlfc;
	tlinetest[0][0][0].elP = pel;
	tlinetest[0][0][0].elT = tel;
	tlinetest[0][0][0].elZ = zel;

        mixlclData = calcLCL(tlinetest[0][0][0].mixParcelP,tlinetest[0][0][0].mixParcelT,tlinetest[0][0][0].mixParcelTd);
        mixplcl = mixlclData[0];
        mixtlcl = mixlclData[1];
        mixzlcl = mixlclData[2];
	tlinetest[0][0][0].lclPmix = mixplcl;
	tlinetest[0][0][0].lclTmix = mixtlcl;
	tlinetest[0][0][0].lclZmix = mixzlcl;

	mixcapeBounds = findLFCandEL("ML");
	mixplfc = mixcapeBounds[0];
	mixtlfc = mixcapeBounds[1];
	mixzlfc = mixcapeBounds[2];
	mixpel = mixcapeBounds[3];
	mixtel = mixcapeBounds[4];
	mixzel = mixcapeBounds[5];
	tlinetest[0][0][0].lfcPmix = mixplfc;
	tlinetest[0][0][0].lfcTmix = mixtlfc;
	tlinetest[0][0][0].lfcZmix = mixzlfc;
	tlinetest[0][0][0].elPmix = mixpel;
	tlinetest[0][0][0].elTmix = mixtel;
	tlinetest[0][0][0].elZmix = mixzel;

	capeArray = getCAPE("SB", 0);//SBCAPE
	cape = capeArray[0];
	pcl_t_arr = capeArray[1];
	cin = capeArray[2];
	brn = capeArray[3][0];
	brnu = capeArray[3][1];
	shr6km = capeArray[3][2];
	tlinetest[0][0][0].cape = cape;
	tlinetest[0][0][0].cin = cin;
	tlinetest[0][0][0].brn = brn;
	tlinetest[0][0][0].brnu = brnu;
	tlinetest[0][0][0].shr6km = shr6km;

	if (pcl_t_arr[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (pcl_t_arr[i] != null) {
				tlinetest[0][0][i].parcelT = pcl_t_arr[i];
			}
		}
	}

	mlcapeArray = getCAPE("ML", 0);//MLCAPE
	mlcape = mlcapeArray[0];
	ml_pcl_t_arr = mlcapeArray[1];
	mlcin = mlcapeArray[2];

	tlinetest[0][0][0].mlcape = mlcape;
	tlinetest[0][0][0].mlcin = mlcin;

	if (ml_pcl_t_arr[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (ml_pcl_t_arr[i] != null) {
				tlinetest[0][0][i].parcelTmix = ml_pcl_t_arr[i];
			}
		}
	}

	var obs_t_arr = new Array();
	var pcl_t_arr = new Array();
	var obs_hght_arr = new Array();
	var ml_pcl_t_arr = new Array();
	for (i=0; i<tlinetest[0][0].length-1; i++) {
		obs_t_arr.push(tlinetest[0][0][i].temp);
		obs_hght_arr.push(tlinetest[0][0][i].hghtagl);
		pcl_t_arr.push(tlinetest[0][0][i].parcelT);
		ml_pcl_t_arr.push(tlinetest[0][0][i].parcelTmix);
	}

	li = calcLI(pcl_t_arr, obs_t_arr);
	tlinetest[0][0][0].LI  = li;

	limix = calcLI(ml_pcl_t_arr, obs_t_arr);
	tlinetest[0][0][0].LImix  = limix;

	tlinetest[0][0][0].LR_1km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 1000);
	tlinetest[0][0][0].LR_2km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 2000);
	tlinetest[0][0][0].LR_3km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 3000);
	tlinetest[0][0][0].LR_5km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 5000);
	tlinetest[0][0][0].LR_7km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 7000);
	tlinetest[0][0][0].LR_9km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 9000);
	tlinetest[0][0][0].LR_10km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 10000);
	tlinetest[0][0][0].LR_EL = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, tlinetest[0][0][0].elZ);

	for (i=0; i< tlinetest[0][0].length; i++) {
		if (tlinetest[0][0][0].lfcP > tlinetest[0][0][i].press) {
			var lfc_index = i
			break;
		}
	}
	tlinetest[0][0][0].LR_lfc_1km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 1000);
	tlinetest[0][0][0].LR_lfc_2km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 2000);
	tlinetest[0][0][0].LR_lfc_3km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 3000);
	tlinetest[0][0][0].LR_lfc_5km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 5000);
	tlinetest[0][0][0].LR_lfc_7km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 7000);
	tlinetest[0][0][0].LR_lfc_9km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 9000);
	tlinetest[0][0][0].LR_lfc_10km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 10000);
	tlinetest[0][0][0].LR_lfc_el = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, tlinetest[0][0][0].elZ-tlinetest[0][0][0].lfcZ);

    // draw initial set of lines
    tlines = membergroup.selectAll("tlines") // Temperature
        .data(tlinetest[0]).enter().insert("path",":first-child")
          .attr("class", function(d,i) { return "temp member" })
          .attr("clip-path", "url(#clipper)")
		  .attr("d", line);
          
    tdlines = membergroup.selectAll("tdlines") // Dewpoint Temperature
        .data(tlinetest[0]).enter().insert("path",":first-child")
          .attr("class", function(d,i) { return "dwpt member" })
          .attr("clip-path", "url(#clipper)")
          .attr("d", line2);

    var line3 = d3.svg.line() // Wet-bulb Temp
        .interpolate("linear")
        .x(function(d,i) { return x(d.twc) + (y(basep)-y(d.press))/tan; })
        .y(function(d,i) { return y(d.press); });

	if ($("#twc_check").prop("checked")) {
		twlines = membergroup.selectAll("twlines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "twc member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line3);
	}

    var line4 = d3.svg.line() // Virtual Temp
        .interpolate("linear")
        .x(function(d,i) { return x(d.tv) + (y(basep)-y(d.press))/tan; })
        .y(function(d,i) { return y(d.press); });

	if ($("#tvc_check").prop("checked")) {		
		tvlines = membergroup.selectAll("tvlines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "tvc member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line4);
	}

//	if (parcel_flag == 1) {
	var line5 = d3.svg.line() // Parcel Temp
		.interpolate("linear")
		.x(function(d,i) { return x(d.parcelT) + (y(basep)-y(d.press))/tan; })
		.y(function(d,i) { return y(d.press); });
				
	if ($("#parcel_check").prop("checked")) {
		parlines = membergroup.selectAll("parcellines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "parcel member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line5);
	}

	var line6 = d3.svg.line() // Mixed Parcel Temp
		.interpolate("linear")
		.x(function(d,i) { return x(d.parcelTmix) + (y(basep)-y(d.press))/tan; })
		.y(function(d,i) { return y(d.press); });
				
	if ($("#parcelmix_check").prop("checked")) {
		parlines = membergroup.selectAll("parcellines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "parcelmix member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line6);
    }

    holines = hodogroup.selectAll("hodolines")
        .data(hodobarbstest[0]).enter().append("path")
    	.attr("class", function(d,i) { return "hodoline member" })
		.attr("d", hodoline);
          
    hododots = hodogroup.selectAll('hododots')
    	.data(flattened.slice(0,55)).enter().append("circle")
    	.attr("r", function(d, i) { return (i<50) ? 4 : 8 })
    	.attr("cx", function(d, i) { return r(d.wspd * Math.sin((180+d.wdir)*d2r)); })
    	.attr("cy", function(d, i) { return -r(d.wspd * Math.cos((180+d.wdir)*d2r)); })
		.attr("class", function(d,i) { return "hododot hgt"+(d.hghtagl/1000) });
	
	if (lat < 0) {
		barbdata = barbgroup.selectAll("barbs")
		.data(barbstest[0][0]).enter().append("g").attr("class","inactiveBarb")
		.attr("transform", function(d,i) { return "translate("+width+","+y(d.press)+") rotate("+(d.wdir-90)+") scale(1,-1)" });
	} else {
		barbdata = barbgroup.selectAll("barbs")
		.data(barbstest[0][0]).enter().append("g").attr("class","inactiveBarb")
		.attr("transform", function(d,i) { return "translate("+width+","+y(d.press)+") rotate("+(d.wdir-90)+")"; });
	}

    allbarbs = barbdata.append("use")
    	.attr("xlink:href", function (d) { return "#barb"+d.wspdround; })
		.attr("transform", function(d,i) { return "rotate(270)"; });

}

function drawText() {
	$(".label").remove();
	d3.selectAll("text.titleText > *").remove();
	d3.selectAll("text.indexVal").remove();
    units = [' mb', ' mb', ' mb', ' mb', ' mb', ' mb', ' J/kg', ' J/kg', ' J/kg', ' J/kg', '', ' m2/s2', ' kts', '', '', '', '', '', ' mb', ' ˚C', ' m', ' mb', ' mb', ' in', " %", " g/kg", " hPa", " g/kg", " K", " K"];
	indices = [];
	indices.push(tlinetest[0][0][0].elP);
	indices.push(tlinetest[0][0][0].elPmix);
	indices.push(tlinetest[0][0][0].lfcP);
	indices.push(tlinetest[0][0][0].lfcPmix);
	indices.push(tlinetest[0][0][0].lclP);
	indices.push(tlinetest[0][0][0].lclPmix);
	indices.push(tlinetest[0][0][0].cape);
	indices.push(tlinetest[0][0][0].mlcape);
	indices.push(tlinetest[0][0][0].cin);
	indices.push(tlinetest[0][0][0].mlcin);
	indices.push(tlinetest[0][0][0].brn);
	indices.push(tlinetest[0][0][0].brnu);
	indices.push(tlinetest[0][0][0].shr6km);
	indices.push(tlinetest[0][0][0].LI);
	indices.push(tlinetest[0][0][0].LImix);
	indices.push(tlinetest[0][0][0].KI);
	indices.push(tlinetest[0][0][0].TT);
	indices.push(tlinetest[0][0][0].SWEAT);

	indices.push(tlinetest[0][0][0].CCL);
	indices.push(tlinetest[0][0][0].tc);
	indices.push(tlinetest[0][0][0].thick);
	indices.push(tlinetest[0][0][0].wbz);
	indices.push(tlinetest[0][0][0].frzl);
	indices.push(tlinetest[0][0][0].pw);

	indices.push(tlinetest[0][0][0].relh);
	indices.push(tlinetest[0][0][0].mr.toPrecision(4));
	indices.push(tlinetest[0][0][0].e.toPrecision(4));
	indices.push(tlinetest[0][0][0].sh);
	indices.push(tlinetest[0][0][0].theta);
	indices.push(tlinetest[0][0][0].thetaE);

    mins = svgtext.selectAll("mins")
	  .data(indices.slice(0,18)).enter().insert("text", ":first-child")
	    .attr('x', 110)
        .attr('y', function(d,i) { return spacing*i; })
		.attr('class', function(d,i) { return 'indexVal ' + labels[i].replace(/\s/g, '').replace(/\(/g, '').replace(/\)/g, ''); })
    	.attr('text-anchor', 'middle')
    	.text(function(d,i) { return d+units[i]});
    	
    maxs = svgtext.selectAll("maxs")
	  .data(indices.slice(18,33)).enter().insert("text", ":first-child")
	    .attr('x', 270)
        .attr('y', function(d,i) { return spacing*i; })
		.attr('class', function(d,i) { return 'indexVal ' + labels[i+18].replace(/\s/g, '').replace(/˚/g, '').replace(/-/g, ''); })
		.attr('text-anchor', 'middle')
    	.text(function(d,i) { return d+units[i+18]});
    
    if (tlinetest[0][0][0].wbz > 100) {
		if ($("#twc_check").prop("checked")) {
			wb0 = labelgroup.selectAll("wbz")
			.data([wb0_pres]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(d)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'wbz_rectline label');
		
			wb0text = labelgroup.selectAll("wbztext")
			.data([wb0_pres]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(d)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'wbztext label')
				.text(function(d,i) { return d + " mb"; });
		}
    }

    if (tlinetest[0][0][0].frzl > 100) {
	for(j=0; j<=tlinetest[0][0][0].frzl.length-1; j++) {
	    frzl = labelgroup.selectAll("frzl")
		  .data([tlinetest[0][0][0].frzl]).enter().insert("rect",":first-child")
	    	.attr('x', width-70)
	    	.attr('y', function(d,i) { return y(d[j])})
	    	.attr('width', 20)
	    	.attr('height', 2)
			.attr('class', 'frzl_rectline label');
	
	    frzltext = labelgroup.selectAll("frzltext")
		  .data([tlinetest[0][0][0].frzl]).enter().insert("text",":first-child")
	    	.attr('x', width-72)
	    	.attr('y', function(d,i) { return y(d[j])})
	    	.attr('dy', '0.4em')
	    	.attr('text-anchor', 'end')
			.attr('class', 'frzltext label')
	    	.text(function(d,i) { return d[j] + " mb"; });
	}
    }

    if (tlinetest[0][0][0].lclP > 100) {
		if ($("#parcel_check").prop("checked")) {
			lcl = labelgroup.selectAll("lcl")
			.data([tlinetest[0][0][0].lclP]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'lcl rectline label');
				
			lcltext = labelgroup.selectAll("lcltext")
			.data([tlinetest[0][0][0].lclP]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'lcltext label')
				.text(function(d,i) { return tlinetest[0][0][0].lclP + " mb"; });
		}
    }

    if (tlinetest[0][0][0].lclPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			lcl = labelgroup.selectAll("lcl")
			.data([tlinetest[0][0][0].lclPmix]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'lclmix rectline label');
				
			lcltext = labelgroup.selectAll("lcltext")
			.data([tlinetest[0][0][0].lclPmix]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'lclmixtext label')
				.text(function(d,i) { return tlinetest[0][0][0].lclPmix + " mb (mix)"; });
		}
    }

    if (tlinetest[0][0][0].lfcP > 100) {
		if ($("#parcel_check").prop("checked")) {
			lfc = labelgroup.selectAll("lfc")
			.data([tlinetest[0][0][0].lfcP]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'lfc rectline label');
				
			lfctext = labelgroup.selectAll("lfctext")
			.data([tlinetest[0][0][0].lfcP]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'lfctext label')
				.text(function(d,i) { return tlinetest[0][0][0].lfcP + " mb"; });
		}
    }

    if (tlinetest[0][0][0].elP > 100) {
		if ($("#parcel_check").prop("checked")) {
			el = labelgroup.selectAll("el")
			.data([tlinetest[0][0][0].elP]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'el rectline label');
				
			eltext = labelgroup.selectAll("eltext")
			.data([tlinetest[0][0][0].elP]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'eltext label')
				.text(function(d,i) { return tlinetest[0][0][0].elP + " mb"; });
		}
    }

    if (tlinetest[0][0][0].lfcPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			lfc = labelgroup.selectAll("lfcmix")
			.data([tlinetest[0][0][0].lfcPmix]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'lfcmix rectline label');
				
			lfctext = labelgroup.selectAll("lfcmixtext")
			.data([tlinetest[0][0][0].lfcPmix]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'lfcmixtext label')
				.text(function(d,i) { return tlinetest[0][0][0].lfcPmix + " mb (mix)"; });
		}
    }

    if (tlinetest[0][0][0].elPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			el = labelgroup.selectAll("elmix")
			.data([tlinetest[0][0][0].elPmix]).enter().insert("rect",":first-child")
				.attr('x', width-70)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix)})
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'elmix rectline label');
				
			eltext = labelgroup.selectAll("elmixtext")
			.data([tlinetest[0][0][0].elPmix]).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix)})
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'elmixtext label')
				.text(function(d,i) { return tlinetest[0][0][0].elPmix + " mb (mix)"; });
		}
    }

    titleText = labelgroup.selectAll("title")
	  .data([title]).enter().insert("text",":first-child")
        .attr('dy', '0.4em')
    	.attr('class', 'titleText')
    	.attr('text-anchor', 'left')
		.attr("transform", "translate(0,-15)")
    	.text(title);
}

function drawToolTips() {
	$(".overlay").remove();
	focusgroup.insert("rect")
	  .attr("class", "overlay") 

	// Define drag beavior
	var drag = d3.behavior.drag()
		.on("dragstart", dragStart)
		.on("touchstart", dragStart)
		.on("drag", dragMove)
		.on("touchmove", dragMove)
		.on("dragend", dragEnd)
		.on("touchend", dragEnd);

  // Draw T/Td tooltips
  focus3 = focusgroup.insert("g",":first-child").attr("class", "focus twc").style("display", "none");
  focus3.append("circle").attr("r", 4);
  focus3.append("text").attr("x", -9).attr("y",14).attr("text-anchor", "end").attr("dy", ".35em");

  focus4 = focusgroup.insert("g",":first-child").attr("class", "focus tvc").style("display", "none");
  focus4.append("circle").attr("r", 4);
  focus4.append("text").attr("x", 9).attr("y",-14).attr("dy", ".35em");

	if (parcel_flag=1) {
	  focus5 = focusgroup.insert("g",":first-child").attr("class", "focus parcel").style("display", "none");
	  focus5.append("circle").attr("r", 4);
	  focus5.append("text").attr("x", 9).attr("y", 14).attr("dy", ".35em");

	  focus5b = focusgroup.insert("g",":first-child").attr("class", "focus parcelmix").style("display", "none");
	  focus5b.append("circle").attr("r", 4);
	  focus5b.append("text").attr("x", 9).attr("y", -14).attr("dy", ".35em");
	}

  focus6 = focusgroup.insert("g",":first-child").attr("class", "focus alt").style("display", "none");
  focus6.append("text").attr("x", 0).attr("text-anchor", "start").attr("dy", ".35em");

  focus6b = focusgroup.insert("g",":first-child").attr("class", "focus pres").style("display", "none");
  focus6b.append("text").attr("x", 11).attr("y", -14).attr("text-anchor", "start").attr("dy", ".35em");

  focus7 = focusgroup.append("g",":first-child").attr("class", "focus windt").style("display", "none").call(dragWind);
  focus7.append("circle").attr("r", 4);
  focus7.append("text").attr("x", -32).attr("text-anchor", "end").attr("dy", ".35em");

  focus2 = focusgroup.append("g").attr("class", "focus dwpc draggable").attr("id","dragDew").style("display", "none").call(drag);
  focus2.append("circle").attr("r", 6);
  focus2.append("text").attr("x", -9).attr("text-anchor", "end").attr("dy", ".35em");
  
  focus = focusgroup.append("g").attr("class", "focus tmpc draggable").attr("id","dragTemp").style("display", "none").call(drag);
  focus.append("circle").attr("r", 6);
  focus.append("text").attr("x", 9).attr("dy", ".35em");

  d3.selectAll(".overlay, .skewt")
  	.attr("width", width)
	.attr("height", height);
}

d3.selectAll(".skewt, .windbarb")
.on("mouseover", function() { $(".focus").show()})
.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb")});

d3.selectAll(".skewt, .windbarb")
	.on("mousemove", mousemove);

var ind = "";
var idx = "";
var mouseTemp = "";

function mousemove() {
	idx = "";
	var y0 = y.invert(d3.mouse(this)[1]); // get y value of mouse pointer in pressure space
	var i = bisectTemp(mouseoverdata, y0, 1, mouseoverdata.length-1);
	var d0 = mouseoverdata[i - 1];
	var d1 = mouseoverdata[i];
	var d = y0 - d0.press > d1.press - y0 ? d1 : d0;
	
	focus.attr("transform", "translate(" + (x(d.temp) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus2.attr("transform", "translate(" + (x(d.dwpt) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus3.attr("transform", "translate(" + (x(d.twc) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus4.attr("transform", "translate(" + (x(d.tv) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus5.attr("transform", "translate(" + (x(d.parcelT) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus5b.attr("transform", "translate(" + (x(d.parcelTmix) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus6.attr("transform", "translate(0," + y(d.press) + ")");
	focus6b.attr("transform", "translate(0," + y(d.press) + ")");
	focus7.attr("transform", "translate(" + width + "," + y(d.press) + ")");

	var currPress = $(".pres").find("text").text().trim().split("m");
	currPress = currPress[0];

	for (k=0; k < tlinetest[0][0].length; k++) {
		var elem = tlinetest[0][0][k].press;
		if (elem == currPress) {
			idx = k;
			break;
		}
	};

	d3.select(".hodogroup circle")
		.attr("cx", function () {return r(d.wspd * Math.sin((180+d.wdir)*d2r))})
		.attr("cy", function () {return -r(d.wspd * Math.cos((180+d.wdir)*d2r))});
	d3.select(".hodogroup line")
		.attr("x2", function () {return r(d.wspd * Math.sin((180+d.wdir)*d2r))})
		.attr("y2", function () {return -r(d.wspd * Math.cos((180+d.wdir)*d2r))});

	$(".windbarb g").attr("class", "inactiveBarb");
	$(".windbarb g:eq(" + idx + ")").attr("class", "activeBarb");
	d3.selectAll(".activeBarb").call(dragWind);

	focus.select("text").text(Math.round(d.temp)+"°C");
	focus2.select("text").text(Math.round(d.dwpt)+"°C");
	focus3.select("text").text(Math.round(d.twc)+"°C");
	focus4.select("text").text(Math.round(d.tv)+"°C");
	focus5.select("text").text(Math.round(d.parcelT)+"°C (SB)");
	focus5b.select("text").text(Math.round(d.parcelTmix)+"°C (mix)");
	focus6.select("text").text("<-"+(Math.round(d.hghtagl/100)/10)+"km");
	focus6b.select("text").text("  " + d.press+"mb");
	focus7.select("text").text(d.wspd+` @`+d.wdir+"˚");
	$(".RH").text(d.relh + "%")
	var mrText = d.mr.toFixed(2) + "\u00A0g/kg";
	$(".MixingRatio").text(mrText)
	var eText = d.e.toFixed(2) + "\u00A0hPa";
	$(".VaporPressure").text(eText);
	$(".SpecHum").text(d.sh + "\u00A0g/kg")
	$(".Theta").text(d.theta + "\u00A0K")
	$(".ThetaE").text(d.thetaE + "\u00A0K")

}

var dragWind = d3.behavior.drag()
		.on("dragstart", dragWindStart)
		.on("touchstart", dragWindStart)
		.on("drag", dragWindMoveCircular)
		.on("touchmove", dragWindMoveCircular)
		.on("dragend", dragWindEnd)
		.on("touchend", dragWindEnd);

var dragLocX;

function dragWindStart () {
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.tmpc, .focus.dwpc, .focus.hod, .focus.hodarrow").css("display", "none");
	dragLocX = d3.mouse(this);
	dragLocX = dragLocX[0];
	event.preventDefault();
}
		
var coords;
var prevCoords = 0;

function rPosition(mouseX, mouseY) {
  var offset = $('.windt circle').offset();
  var x = mouseX - offset.left;
  var y = mouseY - offset.top;
  return [x, y];
}

function dragWindMoveCircular () {
	$(".windbarb g:eq(" + idx + ")").attr("class", "activeBarb");
	d3.selectAll(".skewt, .windbarb")
		.on("mousemove", null)
		.on("mouseover", null)
		.on("mouseout", null);

	var transform = $(this).attr("transform");
	transform = transform.split(")");
	translate = transform[0]
	translate = translate.split(",")
	translateX = translate[0].split("(");
	translateX = parseFloat(translateX[1]);
	translateY = parseFloat(translate[1]);

	var X = $('body').offset().left;
	var Y = $('body').offset().top;
	mouseX = event.pageX - X;
	mouseY = event.pageY - Y;

	var rPos = rPosition(mouseX, mouseY);
	var hypotenuse = Math.sqrt(rPos[0]**2 + rPos[1]**2);
	var angle = Math.atan(rPos[0]/rPos[1])*180/Math.PI;

	if (rPos[0] >= 0 && rPos[1] < 0) { // +x, -y (upper-right quadrant)
		newRotate = -angle-90;
	} else if (rPos[0] < 0 && rPos[1] < 0) { // -x, -y (upper-left quadrant) 
		newRotate = -angle-90;
	} else if (rPos[0] < 0 && rPos[1] >= 0) { // -x, +y (lower-left quadrant)
		newRotate = -angle+90;
	} else { // +x, +y (lower-right quadrant)
		newRotate = -angle-270;
	}

	var currWind = $(".windt").children().text().split("@");
	var currWindSpeed = currWind[0].trim();
	var windDir = newRotate+90;

	if (windDir > 360) {
		windDir = windDir - 360;
	}
	if (windDir < 0) {
		windDir = windDir + 360;
	}

	windDir = windDir.toFixed(0);
	tlinetest[0][0][idx].wdir = parseFloat(windDir);
	if (idx < hodobarbstest[0][0].length) {
		hodobarbstest[0][0][idx].wdir = parseFloat(windDir);
	}

	$(".windt").children().text("" + currWindSpeed + " @" + windDir+ "˚");
	d3.selectAll(".activeBarb").attr("transform","translate(" + translateX + ", " + translateY + ") rotate(" + newRotate + ")");
	drawSkew();
	drawText();
	tabulate();
}
			
function dragWindEnd () {
	d3.selectAll(".skewt, .windbarb")
		.on("mouseover", function() { $(".focus").show()})
		.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb")})
		.on("mousemove", mousemove);
//	$(".activeBarb").children("use").eq(0).hide();
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.tmpc, .focus.dwpc").css("display", "");
}

var yTrans = 0;

function dragStart(d) {
	event.preventDefault();
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.windt").css("display", "none");
	yTrans = d3.select(this).attr("transform");
  	yTrans = yTrans.split(",");
  	yTrans = yTrans[1].split(")");
  	yTrans = yTrans[0];
}

function dragMove(d) {
	var xLoc = d3.event.x;
  $(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.windt, .focus.hod, .focus.hodarrow").css("display", "none");

  d3.selectAll(".skewt, .windbarb")
  	.on("mousemove", null)
	.on("mouseover", null)
	.on("mouseout", null);

  var pres = [];
  for (k=0; k < tlinetest[0][0].length; k++) {
	var elem = tlinetest[0][0][k].press;
	pres.push(elem);
  };

  var currPress = $(".pres").find("text").text().trim().split("m");
  currPress = currPress[0];
  ind = pres.indexOf(parseFloat(currPress));
  if (xLoc >= 0 && xLoc < 625) {
	  d3.select(this).attr("transform", "translate(" + xLoc + "," + yTrans + ")");
  } else {
		return;
  }

  var elId = $(this).attr("id");

  if (elId == "dragDew") {
		var otherXLoc = $("#dragTemp").attr("transform");
		otherXLoc = otherXLoc.split(",");
		otherXLoc = otherXLoc[0].split("(");
		otherXLoc = otherXLoc[1];
		
		if (xLoc >= 0 && xLoc < 625) {
			mouseTemp = x.invert(xLoc - (y(basep)-yTrans)/tan);
			// Redraw label (truncated value)
			$(this).find('text').text(Math.round(mouseTemp) + "˚C");
			// Modify that element in line2[el] or tlinetest[0][0][el].dwpt
			tlinetest[0][0][ind].dwpt = parseFloat(mouseTemp.toFixed(2));
			if (otherXLoc <= xLoc) {
				tlinetest[0][0][ind].temp = parseFloat(mouseTemp.toFixed(2));
				d3.select("#dragTemp").attr("transform", "translate(" + xLoc + "," + yTrans + ")");
			}
		}

  } else if (elId == "dragTemp") {
	var otherXLoc = $("#dragDew").attr("transform");
		otherXLoc = otherXLoc.split(",");
		otherXLoc = otherXLoc[0].split("(");
		otherXLoc = otherXLoc[1];

		if (xLoc >= 0 && xLoc < 625) {
			mouseTemp = x.invert(xLoc - (y(basep)-yTrans)/tan);
			// Redraw label (truncated value)
			$(this).find('text').text(Math.round(mouseTemp) + "˚C");
			// Modify the element in line[el] or tlinetest[0][0][el].temp
			tlinetest[0][0][ind].temp = parseFloat(mouseTemp.toFixed(2));
			if (otherXLoc >= xLoc) {
				tlinetest[0][0][ind].dwpt = parseFloat(mouseTemp.toFixed(2));
				d3.select("#dragDew").attr("transform", "translate(" + xLoc + "," + yTrans + ")");
			}
		}

		
  } else {
	  	console.log("Didn't find that ID for dragging");
  }
  drawSkew();
  drawText();
  tabulate();

  if (xLoc <= 0) {
	  dragEnd();
  } else if (xLoc > 625) {
	  dragEnd();
  }

}

function dragEnd(d) {
  d3.selectAll(".skewt, .windbarb").on("mousemove", mousemove);
  $(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.windt, .focus.hod, .focus.hodarrow").css("display", "");

  d3.selectAll(".skewt, .windbarb")
  	.on("mouseover", function() { $(".focus").show()})
  	.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb")});

}

function drawTextLabels() {

	spacing = 20;
	var headers = ['Values', '', 'Values'];
	labels = ['EL', 'EL (mixed)', 'LFC', 'LFC (mixed)', 'LCL', 'LCL (mixed)', 'SBCAPE', 'MLCAPE', 'CIN', 'MLCIN', 'BRN', 'BRN Shear', 'Shear 6km', 'LI', 'LI (mixed)', 'KI', 'TT', 'SWEAT', 'CCL', 'Tc', 'Thickness', 'Wet-Bulb 0˚', 'Freezing Lvl', 'PW', 'RH', 'Mixing Ratio', 'Vapor Pressure', 'Spec Hum', 'Theta', 'ThetaE'];
    
    svgtext.selectAll("labels")
     .data(labels.slice(0,18)).enter().append("text")
        .attr('x', 70)
        .attr('y', function(d,i) { return spacing*i; })
    	.attr('class', 'index header')
    	.attr('text-anchor', 'end')
    	.text(function(d) { return d; });
    	
    svgtext.selectAll("labels2")
     .data(labels.slice(18,34)).enter().append("text")
        .attr('x', 220)
        .attr('y', function(d,i) { return spacing*i; })
    	.attr('class', 'index header')
    	.attr('text-anchor', 'end')
    	.text(function(d) { return d; });
    	
    svgtext.selectAll("headers")
      .data(headers).enter().append("text")
        .attr('x', function(d,i) { return 110 + 80*i; })
        .attr('y', -20)
    	.attr('class', 'index header')
    	.attr('text-anchor', 'middle')
    	.text(function(d) { return d; });
    	
}

function interpVal (pres, p_lo, p_hi, lo_val, hi_val) {
	range = (lo_val - hi_val);
	fraction = (p_hi - pres)/(p_hi - p_lo);
	interp = (fraction * range) + hi_val;
	mean = (interp + hi_val) / 2;
	return mean;
}

function calcWetbulb (press, t, dp) // From Interactive Skew-T FLA
{
// Calculates the wetbulb given the pressure (mb), temperature (c), and dewpoint (c)
// This algorithm differs from the one used in the Gary Skaggs program by using a binary-search type approximation
// instead of a brute-force approach. You get a more accurate answer more quickly.
// In an interpreted (slow) language like Javascript, the more efficient the algorithm the better.

	var tmin=dp;
	var vpdp=calcVaporPressure(dp);
	var vpcur;
	var peq;
	var diff;
	var tmax=t;
	var tcur;

	//while (true)
	for(i=0;i<100;i++)
	{
		//trace(i);
		tcur=(tmax+tmin)/2;
		vpcur=calcVaporPressure(tcur);
		peq=0.000660*(1+0.00155*tcur)*press*(t-tcur);
		diff=peq-vpcur+vpdp;
		if (Math.abs(diff) < 0.01)
			break;

		if (diff < 0)
			tmax=tcur;
		else
			tmin=tcur;
	}
	return Math.round(tcur*10)/10;
}

function calcVaporPressure( temp )
{
//	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(temp+273)));
	vp = 6.11 * Math.exp(5321 * (1/273 - 1/(temp+273)));
	return vp;
}

function calcWetbulbZero() // From Interactive Skew-T FLA
{
	var wb0 = 99;
	var wb1 = 99;
	//from the bottom-up, search for the first wb < 0
	for(i=0; i<tlinetest[0][0].length-1; i++){
		wb0 = tlinetest[0][0][i].twc;
		if(wb0 <= 0){
			wb0_index = i;
			break;
		}else{
			wb1 = wb0;
		}
	}
	//establish the range from level to level
	range_fraction = Math.abs(wb0/(wb1 - wb0));
	log_lop = log10(tlinetest[0][0][wb0_index].press);
	if (wb0_index == 0) {
		log_hip = log10(tlinetest[0][0][wb0_index].press);
	} else {
		log_hip = log10(tlinetest[0][0][wb0_index-1].press);
	}
	logp_wb0 = (range_fraction * (log_hip - log_lop)) + log_lop;
	return Math.round(Math.pow(10, logp_wb0));
}

function calcMixingRatio (vapor, press)
{
	return (((0.62197*vapor)/(press-vapor))*1000.0);
}


function calcRelHumidity (ambient, satur)
{
	return Math.round( ambient/satur * 1000)/10;
}

function calcSpecHumidity (vapor, pressure )
{
	return Math.round(100000*0.622*vapor/pressure)/100;
}

function log10(x) {
	return (Math.log(x) / Math.log(10));	
}

function calcLCL(pres, t, dp)
{
//http://www.shodor.org/os411/courses/_master/tools/calculators/lcl/lcl3calc.html
	var P = parseFloat(pres);
	var TK = parseFloat(t) + 273.16;
	var TDK = parseFloat(dp) + 273.16;
	A = 1 / (TDK - 56);
	B = Math.log (TK/TDK)/800;
	TCK = 1 / (A+B) + 56;
	var lcl_t = Math.round((TCK-273.15)*10)/10;
	var lcl_p = Math.round(P * Math.pow(TCK / TK, 3.5037));

	for (i=0; i<tlinetest[0][0].length-1; i++) {
		if (tlinetest[0][0][i].press < lcl_p) {
			p_lo = tlinetest[0][0][i].press;	
			h_lo = tlinetest[0][0][i].hghtagl;	
			break;
		} else if (lcl_p == tlinetest[0][0][i].press) {
			return [lcl_p, lcl_t, tlinetest[0][0][i].hghtagl];
		} else {
			p_hi = tlinetest[0][0][i].press;	
			h_hi = tlinetest[0][0][i].hghtagl;	
		}
	}
	
	var lcl_z = interpVal(lcl_p, p_lo, p_hi, h_lo, h_hi);
	return [lcl_p, lcl_t, lcl_z];
}

function calcCCL()
{
	//calculate the vapor pressure for the parcel
	var vp_pcl = calcVaporPressure(td_pcl100); //parcel vapor pres

	//use that to compute the parcel mixing ratio
	var mr_pcl = calcMixingRatio(vp_pcl, p_pcl100); //parcel mix ratio

	//now, start climbing the temp profile, computing saturation mr at each step.
	//continue until mr_sat is less than mr_pcl.
	//also keep track of previous step
	var smr0 = -1; //current sat mr 
	var smr1 = -1; //previous sat mr

	//loop from bottom up of sounding
	for(i=1; i<tlinetest[0][0].length-1; i++){
		if(p_pcl100 > tlinetest[0][0][i].press){
			var svp0 = calcVaporPressure(tlinetest[0][0][i].temp);
			var smr0 = calcMixingRatio(svp0,tlinetest[0][0][i].press) ;

			//calc cat mr along sounding, then compare to pcl mr
			if(smr0 < mr_pcl){
				if(smr1 == -1){//if first calc of sat mr is less than pcl, 
					//then assume that parcel pres is ccl
					pccl = p_pcl100
					tccl = t_pcl100
				}else{
					//otherwise need to interpolate to obtain ccl pressure and temp
					pccl = tlinetest[0][0][i-1].press - ((tlinetest[0][0][i-1].press - tlinetest[0][0][i].press) * (smr1 - mr_pcl)/(smr1 - smr0)); 
					tccl = tlinetest[0][0][i-1].temp - ((tlinetest[0][0][i-1].temp - tlinetest[0][0][i].temp) * (smr1 - mr_pcl)/(smr1 - smr0)); 
				}	
				break;
			}else{
				smr1 = smr0;
			}
		}
	}
	return Math.round(pccl);
}

function calcConvTemp()
{
	theta_ccl = calcTheta(pccl, tccl);
	sfc_p = tlinetest[0][0][0].press;
	ctK = theta_ccl / Math.pow(1000/sfc_p ,0.2854*(1-0.00028*tlinetest[0][0][0].mr));
	ct = ctK - 273.15;
	return Math.round(ct*10)/10;
}

function calcVirtualtemperature(Tc,mixr)
{
	return Math.round(10 * (Tc + (mixr/6)))/10; 
}

function calcPrecipWater()
{
	var pw = 0;
	var sh0 = 0;	//current sh
	var p0 = 0;	//current p
	var q0 = 0;	//current q
	var p1 = 0;	//previous p
	var q1 = 0;	//previous q	
	
	for(i=0; i<tlinetest[0][0].length-1; i++){
		dp0 = 273.15 + tlinetest[0][0][i].dwpt;//T=dyntext field
		p0 = tlinetest[0][0][i].press;
		eee = Math.exp(33.09376 - 0.0091379024 * dp0 - 6106.3960 / dp0);
		q0= eee/(p0 - 0.00066771703 * eee);
		q0 = q0 / 1000;//convert to kg/kg
		p0=p0*100;//convert to Pa
		if(i > 0){
			pw += 0.5 * (q0 + q1) * (p1 - p0) * (1/(g * 1000));
		}
		p1=p0;
		q1=q0
	}
	return Math.round(pw * 1000/25.4 *100)/100;
}

function calcSWEAT()
{
	ttdiff = tlinetest[0][0][0].TT - 49;
	if (ttdiff < 0){ttdiff = 0}

	delta_d = wd500 - wd850;
	if (delta_d < 0) {delta_d = 0}

	wind_term = 125*(Math.sin(delta_d * 0.017453293)+0.2);

	if (wd850 >= 130 && wd850 <= 250) {
		wind_term = 0;
	}
	if (wd500 >= 210 && wd500 <= 310) {
		wind_term = 0;
	}
	if (delta_d > 0) {
		wind_term = 0;
	}
	if (ws850 < 15 && ws500 < 15) {
		wind_term = 0;
	}


	if (td850 < 0) {
		term1 = 0;
	} else {
		term1 = 12*td850;
	}

	num = term1 + (20*ttdiff) + (2*ws850) + ws500 + wind_term;
	return Math.round(num);
}

function calcKI()
{
	return Math.round(t850 + td850 - t500 - t700 + td700);
}

function calcTT()
{
	return Math.round(t850 + td850 - (2*t500));
}

function calcFreezeLevel()
{
	var temp0;
	var temp1;
	var temp_frz_t_arr = new Array();
	var logp_temp0_arr = new Array();
	var j = 0;
	for(i=0; i<tlinetest[0][0].length-1; i++){
		temp0 = tlinetest[0][0][i].temp;
		if(temp0 <= 0){
			if (i > 0) {
				if (tlinetest[0][0][i-1].temp > 0) {
					temp_frz_t_arr[j] = [temp0, tlinetest[0][0][i-1].temp, tlinetest[0][0][i].press];
					j++;
				}
			} else {
				temp_frz_t_arr[j] = [temp0,temp0,tlinetest[0][0][i].press];
				j++;
			}
		}
	}
	for (k=0; k<=temp_frz_t_arr.length-1; k++) {
		//establish the range from level to level
		if (temp_frz_t_arr[k][0] != temp_frz_t_arr[k][1]) {
			range_fraction = Math.abs(temp_frz_t_arr[k][0])/(temp_frz_t_arr[k][1] - temp_frz_t_arr[k][0]);
		} else {
			range_fraction = 1;
		}
		log_lop = log10(temp_frz_t_arr[k][2]);
		log_hip = log10(temp_frz_t_arr[k][2]);
		logp_temp0 = (range_fraction * (log_hip - log_lop)) + log_lop;
		logp_temp0_arr.push(Math.round(Math.pow(10, logp_temp0)));
	}
	return logp_temp0_arr;
}

function deg2rad(degrees)
{
	return(degrees * 2 * Math.PI / 360);
}

//this function returns BRN and BRNshear
//based on code by Keith Brewster found at this URL:
//http://www.caps.ou.edu/ARPS/arps5Beta8Browser/arps5.0Beta8browser/html_code/adas/thermo3d.f90.html
function getBRN(cape)
{
	var shear_sum=0;
	var thk_sum=0;
	var sumu=0;
	var sumv=0;
	var sump=0;
	var sumz=0;
	var layerz=0;
	var rholo=0;
	var u_lo=0;
	var v_lo=0;
	//init and calc u and v at the top (lo refers to the density or pressure, not z)
	var d_hi = deg2rad(tlinetest[0][0][0].wdir);
	var u_hi = tlinetest[0][0][0].wspd * Math.sin(d_hi);
	var v_hi = tlinetest[0][0][0].wspd * Math.cos(d_hi);

	//init and calc rhohi at the lowest elevation
	rho_index = 0;
	var rhohi = (tlinetest[0][0][rho_index].press * 100) / (tlinetest[0][0][rho_index].temp + 273.15); //init this at the lowest elevation

	//iterate from the bottom up.
	for(i=0; i<=tlinetest[0][0].length-1; i++){
	  //calc the thickness of the layer
		//first, find the mean temp
		var t1 = getTv(tlinetest[0][0][i].temp, tlinetest[0][0][i].dwpt, tlinetest[0][0][i].press);
		var t2 = getTv(tlinetest[0][0][i+1].temp, tlinetest[0][0][i+1].dwpt, tlinetest[0][0][i+1].press);
		var Tbar = 273.15 + (t1+t2)/2;
		//second, retrieve the pressure at this level (i) and the next one up (i+1)
		var p1 = tlinetest[0][0][i].press;
		var p2 = tlinetest[0][0][i+1].press;
		//last, calculate the layer thickness
		layerz = ((R * Tbar) / g) * Math.log(p1/p2);
	  //piggy-back the 1000:500 thickness here
	  if( tlinetest[0][0][i].press == 500){
			getThickness(thk_sum);
	  }
	  //check to see if we're at the 500m level.
	  //if so, get the u and v 500m
		if(sumz < 500 && (sumz + layerz) > 500){
			//go into interpolation routine
			//calc the fraction for interpolation
			var fraction = (500 - sumz)/layerz;
			var dp = ((p1-p2)*fraction);
			//now determine the u and v components for the topmost layer, ending at 6 km
			//first get the u and v at the top, above 6 km
			var dtop = deg2rad(tlinetest[0][0][i+1].wdir);
			var utop = tlinetest[0][0][i+1].wspd * Math.sin(dtop);
			var vtop = tlinetest[0][0][i+1].wspd * Math.cos(dtop);
			//next, determine the u and v at 6 km, 
			u_lo = ((utop - u_hi) * fraction) + u_hi;
			v_lo = ((vtop - v_hi) * fraction) + v_hi;
			//next, determine the density at the top of the layer
			var rho500 = ((dp + p1) * 100) / (t2 + 273.15); //rho = p in Pa / T in Kelvin
			var sumu500 = sumu + (dp * ((rholo * u_lo)+(rhohi * u_hi)) / (rholo + rhohi));
			var sumv500 = sumv + (dp * ((rholo * v_lo)+(rhohi * v_hi)) / (rholo + rhohi));
			//add delta p to the running pressure total
			var sump500 = sump + dp;
			var u500m = 0.514444444 * sumu500/sump500;//calc and convert from kt to m/s
			var v500m = 0.514444444 * sumv500/sump500;
		}//end 500m wind calc
	  //check to see if we're above 6000m
		if((sumz + layerz) > 6000){
			//go into interpolation routine
			//calc the fraction for interpolation
			var fraction = (6000 - sumz)/layerz;
			var dp = ((p1-p2)*fraction);
			//now determine the u and v components for the topmost layer, ending at 6 km
			//first get the u and v at the top, above 6 km
			var dtop = deg2rad(tlinetest[0][0][i+1].wdir);
			var utop = tlinetest[0][0][i+1].wspd * Math.sin(dtop);
			var vtop = tlinetest[0][0][i+1].wspd * Math.cos(dtop);
			//next, determine the u and v at 6 km, 
			u_lo = ((utop - u_hi) * fraction) + u_hi;
			v_lo = ((vtop - v_hi) * fraction) + v_hi;
			//next, determine the density at the top of the layer
			rholo = ((dp + p1) * 100) / (t2 + 273.15); //rho = p in Pa / T in Kelvin
			sumu += dp * ((rholo * u_lo)+(rhohi * u_hi)) / (rholo + rhohi);
			sumv += dp * ((rholo * v_lo)+(rhohi * v_hi)) / (rholo + rhohi);
			shear_sum += Math.sqrt(((v_lo-v_hi)*(v_lo-v_hi)) + ((u_lo-u_hi)*(u_lo-u_hi)));
			//add delta p to the running pressure total
			sump += dp;
			temp = 1000 - sump;
			//we're done, so break out of the for loop
			break;
		}else{
			sumz += layerz;
			if(tlinetest[0][0][i].press <= 1000){
				thk_sum += layerz;
			}
			dp = tlinetest[0][0][i].press - tlinetest[0][0][i+1].press;
			sump += dp;
			//first get the u and v at the top (lo refers to the density or pressure, not z)
			var d_lo = deg2rad(tlinetest[0][0][i+1].wdir);
			var u_lo = tlinetest[0][0][i+1].wspd * Math.sin(d_lo);
			var v_lo = tlinetest[0][0][i+1].wspd * Math.cos(d_lo); 
			//determine the density at the top of the layer
			rholo = (p2 * 100) / (t2 + 273.15); //rho = p in Pa / T in Kelvin
			//with the top and bottom rho, u, and v
			//determine the density weighted component of u and v
			//and add it to the running total
			sumu += dp * ((rholo * u_lo)+(rhohi * u_hi)) / (rholo + rhohi);
			sumv += dp * ((rholo * v_lo)+(rhohi * v_hi)) / (rholo + rhohi); 
			shear_sum += Math.sqrt((v_lo-v_hi)*(v_lo-v_hi) + (u_lo-u_hi)*(u_lo-u_hi));
			//take those values calculated for the upper level (lower p and rho) 
			//and assign them to the lower level (higher p and rho)
			rhohi = rholo;
			u_hi = u_lo;
			v_hi = v_lo;
		} //end if/then for 6km or not
	}//end for loop
	u6km = 0.514444444*sumu/sump //calc and convert to m/s
	v6km = 0.514444444*sumv/sump
	brnu = (((u6km-u500m)*(u6km-u500m)) + ((v6km-v500m)*(v6km-v500m))) / 2;
	brnu = Math.round(brnu);
	brn = Math.round(cape / brnu);
	shear6km = Math.round(shear_sum);
	return [Math.round(brn), brnu, shear6km];;
}

function getCAPE(capeType, useTv)
{
var el_index = 999;
var lfc_index = 999;
var cape = 0;

if (capeType == "ML") {
	var press_EL = tlinetest[0][0][0].elPmix;
	var press_LFC = tlinetest[0][0][0].lfcPmix;
	var press_LCL = tlinetest[0][0][0].lclPmix;
	var temp_LCL = tlinetest[0][0][0].lclTmix;
} else if (capeType == "SB") {
	var press_EL = tlinetest[0][0][0].elP;
	var press_LFC = tlinetest[0][0][0].lfcP;
	var press_LCL = tlinetest[0][0][0].lclP;
	var temp_LCL = tlinetest[0][0][0].lclT;
} else if (capeType == "Moist Adiabats") {
	var press_EL = 100;
	var press_LFC = 1000;
	var press_LCL = 1000;
	var temp_LCL = 10;
} else {
	var press_EL = tlinetest[0][0][0].elP;
	var press_LFC = tlinetest[0][0][0].lfcP;
	var press_LCL = tlinetest[0][0][0].lclP;
	var temp_LCL = tlinetest[0][0][0].lclT;
}

//if(tlinetest[0][0][0].elP != 0){	
	//let's start by wiping the parcel_temp_array
	for(i in parcel_temp_array){
		parcel_temp_array[i] = null;	
	}
	//and reinitializing
	var sumCAPE = 0;
	//starting from the top down
	//find the first obs level below the EL
	for(i=tlinetest[0][0].length-1; i>0; i--){
		if(tlinetest[0][0][i].press > press_EL){
			el_index = i;
			break;
		}
	}
	//starting from the bottom up
	//find the first obs level above the LFC
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if(tlinetest[0][0][i].press < press_LFC){
			lfc_index = i;
			break;
		}
	}
	//starting from the bottom up
	//find the first obs level above the LCL
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if(tlinetest[0][0][i].press < press_LCL){
			lcl_index = i;
			break;
		}
	}

	//let's populate an array with tempC's along the moist adiabat
	for(i=tlinetest[0][0].length-1; i>=0; i--){
		if (i < lcl_index) {
			theta_lcl = calcTheta(press_LCL,temp_LCL);
			parcel_temp_array[i] = theta2C(theta_lcl, tlinetest[0][0][i].press)
		} else {
			//get the parcel temperature at the current level
			thetae_lcl=calcThetaE(press_LCL, temp_LCL, temp_LCL);
			temp_t = findTC(thetae_lcl, tlinetest[0][0][i].press);
			//drop it into an array
			parcel_temp_array[i] = temp_t;
		}

		if(i==el_index){//starting at the EL and working down
			//mean obs temp of the layer
			mean_t = (tlinetest[0][0][el_index].temp + temp_t) / 2;
			//thickness of the layer
			if (!press_EL) {
			} else {
				dz = calcThickness(tlinetest[0][0][i].press, press_EL, mean_t);
				//dt is the diff between pcl temp and obs temp (C) used to compute area
				dt = (temp_t - tlinetest[0][0][i].temp) / 2;//it's a triangle, so divide dt by 2 to get the proper area
				sumCAPE += (dz * dt) / (mean_t + 273.15);
			}
		}else if (i==lfc_index){//now check to see if we're at the LFC
			tlfc = findTC(thetae_lcl, press_LFC);//get temp at LFC
			mean_t = (tlfc + temp_t) / 2; //get layer mean temp
			dz = calcThickness(press_LFC, tlinetest[0][0][i].press, mean_t);//get layer thickness
			dt = (temp_t - tlinetest[0][0][i].temp) / 2;//get pcl/obs temp diff
			sumCAPE += (dz * dt) / (mean_t + 273.15); //add to sum
		}else if (i<el_index && i>lfc_index) { //in the middle, between the EL and LFC
			mean_t = (tlinetest[0][0][i].temp + tlinetest[0][0][i-1].temp) / 2;
			dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][i+1].press, mean_t);
			dt0 = parcel_temp_array[i] - tlinetest[0][0][i].temp;// pcl temp - obs temp at current level
			dt1 = temp_t - tlinetest[0][0][i+1].temp;// pcl temp - obs temp at level above
			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCAPE += (dz * mean_dt) / (mean_t + 273.15);// add to sum
		} else {
		}
	}
	var cape = g * sumCAPE; //multiply time g to get cape

	if(cape <= 0){
		cape = 0;//if cape<0, then set it to 0
	}
	cinArray = getCIN(parcel_temp_array, capeType);
	cin = cinArray[0];
	brn_arr = getBRN(cape); //calculate BRN

	return [Math.round(cape), parcel_temp_array, cin, brn_arr]; //return a value - gets posted in parameters

}
/**********************************************************************/
function calcTheta(P,T)
{
	//trace("calcTheta")
	num = (T + 273.15) * Math.pow(1000/P ,0.286);
	return Math.round(num*10)/10;
}

function theta2C(thetaK,P)
/*
based on function TDA at http://wahiduddin.net/calc/density_algorithms.htm
RETURNS THE TEMPERATURE TDA (CELSIUS) ON A DRY ADIABAT
AT PRESSURE P (MILLIBARS). THE DRY ADIABAT IS GIVEN BY
POTENTIAL TEMPERATURE O (CELSIUS).
*/
{
	//var thetaK= theta+273.15;
	//var TDAK= thetaK*((P*.001)**.286);
	var TDAK= thetaK * Math.pow(P*.001,0.286)
	var TDA= TDAK-273.15;
	return Math.round(TDA*10)/10;
}
/**********************************************************************/

function getCIN(t_arr, flag)
{
	lfc_index = 0;
	//first off, let's see if the lfc lies within our BL
	//if so, then cin = 0, so we return 0, which concludes the function.
	if (flag == "ML") {
		if(tlinetest[0][0][0].lfcPmix >= tlinetest[0][0][0].mixParcelP - bl_depth/2 || tlinetest[0][0][0].lfcPmix == -1){
			cin = 0;
			return [cin];
		}
		lfc_press = tlinetest[0][0][0].lfcPmix;
		lfc_temp = tlinetest[0][0][0].lfcTmix;
		lcl_press = tlinetest[0][0][0].lclPmix;
		lcl_temp = tlinetest[0][0][0].lclTmix;

		//now let's find the first level above the top of the mixed layer
		for(i=0; i<tlinetest[0][0].length-1; i++){
			if(tlinetest[0][0][i].press <= tlinetest[0][0][0].mixParcelP - bl_depth/2){
				pcl_index = i;
				break;
			}
		}
	
	} else {
		lfc_press = tlinetest[0][0][0].lfcP;
		lfc_temp = tlinetest[0][0][0].lfcT;
		lcl_press = tlinetest[0][0][0].lclP;
		lcl_temp = tlinetest[0][0][0].lclT;
		pcl_index = 0;
	}
	//and reinitializing
	var sumCIN = 0;

	//starting from the top down
	//find the first obs level below the LFC
	for(i=tlinetest[0][0].length-1; i>0; i--){
		if(tlinetest[0][0][i].press > lfc_press){
			lfc_index = i;
			break;
		}
	}
	for(i=tlinetest[0][0].length-1; i>0; i--){
		if(tlinetest[0][0][i].press > lcl_press){
			lcl_index = i;
			break;
		}
	}
	//let's populate an array with parcel tempC's 
	//along the moist adiabat above the LCL
	//along a dry adiabat below the LCL

	//now start the computation...
	//first, a little short hand
	if (flag =="ML") {
		var pcl_press = tlinetest[0][0][pcl_index].press; //pressure at the pcl_index
		var pblt = tlinetest[0][0][0].mixParcelP - bl_depth/2; //pressure at the top of the boundary layer = 
	} else {
		var pcl_press = tlinetest[0][0][0].press;
		var pblt = tlinetest[0][0][0].mixParcelP - bl_depth/2; //pressure at the top of the boundary layer = 
	}

	//first we see if there is any cin between the pcl_index level, where we will start our calculation
		if(pcl_press < pblt){
			//first we need the obs t and pcl t at the top of the boundary layer
			//get this through interpolation
			//first the obs temp
			pHi = tlinetest[0][0][pcl_index-1].press; //(base of layer)
			pLo = pcl_press;//pressure at pcl_index (top of layer)
			tHi = tlinetest[0][0][pcl_index-1].temp; 
			tLo = tlinetest[0][0][pcl_index].temp;
			fraction = (pHi-pblt) / (pHi-pLo); 
			tblt_obs =  tHi - (fraction * (tHi - tLo));//obs t at BL top
			//now the pcl temp
			//first, we have to establish where the lcl is relative to the top of the BL (or BLT)
			if(lcl_press < pcl_press || lcl_press >= ppcl){
				pHi = tlinetest[0][0][0].press; //pressure at BL center
				pLo = tlinetest[0][0][lcl_index].press;//pressure at pcl_index
				tHi = tlinetest[0][0][0].temp; //temp at BL center
				tLo = tlinetest[0][0][lcl_index].temp; // temp at pcl_index level
			}else if(pcl_press <= lcl_press && lcl_press <= pblt){
				pHi = tlinetest[0][0][0].press; //pressure at BL center (base of layer)
				pLo = lcl_press; //pressure at lcl
				tHi = tlinetest[0][0][0].temp; //temp at BL center
				tLo = lcl_temp; // temp at lcl
			}else if(pcl_press <= pblt && pblt <= lcl_press){
				pHi = lcl_press;//pressure at lcl
				pLo = pcl_press;//pressure at pcl_index (top of layer)
				tHi = lcl_temp; //temp at lcl
				tLo = t_arr[pcl_index];// temp at pcl_index level
			}
			fraction = (pHi-pblt) / (pHi-pLo); 
			tblt_pcl =  tHi - (fraction * (tHi - tLo));//obs t at BL top
	
			//now we're prepared to calculate cin for this layer
			//first check whether plfc >pcl_press 
			//if so, use plfc as the top, else use pcl_press as the top
			if(lfc_press > pcl_press){
				mean_t = (lfc_temp + tblt_obs) / 2;
				dz = calcThickness(pblt, lfc_press, mean_t);
				dt0 = 0;// pcl temp - obs temp at level above
				dt1 = tblt_pcl - tblt_obs;// // pcl temp - obs temp at present level
				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
				//since we just computed from the blt to the lfc, we're done.
				//finish computation and return value
				var cin = g * sumCIN; //multiply time g to get cape
				return Math.round(cin); //return a value - gets posted in parameters
			}else{
				mean_t = (tlinetest[0][0][pcl_index].temp + tblt_obs) / 2;
				dz = calcThickness(pblt, pcl_press, mean_t);
				dt0 = t_arr[pcl_index+1] - tlinetest[0][0][pcl_index+1].temp;// pcl temp - obs temp at level above
				dt1 = tblt_pcl - tblt_obs;// // pcl temp - obs temp at present level
				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
			}
		}	
	//next we integrate from the pcl_index up to just short of the triangle topped by the lfc, which we will treat seperately at the end
	for(i=0; i<lfc_index; i++){
		//case 1 - entire layer either above or below lcl
		if(tlinetest[0][0][i+1].press > lcl_press || tlinetest[0][0][i].press < lcl_press){
			mean_t = (tlinetest[0][0][i].temp + tlinetest[0][0][i+1].temp) / 2;//need tlcl_obs
			dz = calcThickness(tlinetest[0][0][i].press,tlinetest[0][0][i+1].press, mean_t);
			dt0 = t_arr[i+1] - tlinetest[0][0][i+1].temp;// pcl temp - obs temp at level above
			dt1 = t_arr[i] - tlinetest[0][0][i].temp;// // pcl temp - obs temp at present level
			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum

		} else { //layer straddles the lcl
			//first find the observed temp at the lcl
			pHi = tlinetest[0][0][i].press;
			pLo = tlinetest[0][0][i+1].press;
			tHi = tlinetest[0][0][i].temp;
			tLo = tlinetest[0][0][i+1].temp;
			fraction = (pHi-lcl_press) / (pHi-pLo);
			tlcl_obs =  tHi - (fraction * (tHi - tLo))//obs t at LCL
			//now compute from the base of the layer up to the lcl
			mean_t = (tHi + tlcl_obs) / 2;
			dz = calcThickness(pHi, lcl_press, mean_t);
			dt0 = lcl_temp - tlcl_obs;// pcl temp - obs temp at LCL
			dt1 = t_arr[i] - tlinetest[0][0][i].temp;// // pcl temp - obs temp at present level
			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
			//now compute from the lcl to the top of the layer
			mean_t = (tLo + tlcl_obs) / 2;
			dz = calcThickness(lcl_press, pLo, mean_t);
			dt0 = lcl_temp - tlcl_obs;// pcl temp - obs temp at LCL
			dt1 = t_arr[i+1] - tlinetest[0][0][i+1].temp;// // pcl temp - obs temp at level above present level
			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
		}
	}

	//now, the last bit up to the lfc
	mean_t = (lfc_temp + tlinetest[0][0][lfc_index].temp) / 2; //need tlcl_obs
	dz = calcThickness(tlinetest[0][0][lfc_index].press, lfc_press, mean_t);
	dt0 = 0;// pcl temp = obs temp at lfc, so dt0=0
	dt1 = t_arr[lfc_index] - tlinetest[0][0][lfc_index].temp;// // pcl temp - obs temp at present level
	mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
	sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
	lfc_cin = g*(dz * mean_dt) / (mean_t + 273.15);
	//finish up...
	var cin = g * sumCIN; //multiply time g to get cin
	if(cin > 0 || cin === undefined || isNaN(cin)) {
		cin = 0;
	}

	return [Math.round(cin)]; //return a value - gets posted in parameters
}
/***************************************************************/
function calcThickness(p1, p2, t)
{
	//the crux of this is finding the mean temp for the layer
	//otherwise, the calculation is pretty simple: z2-z1 = (R*T/g)*ln(p2/p1);
	Tbar = 273.15 + t;
	delta_z = ((R * Tbar) / g) * Math.log(p1/p2);
	return Math.round(delta_z);
}

function calcThick()
{
	//the crux of this is finding the mean temp for the layer
	//otherwise, the calculation is pretty simple: z2-z1 = (R*T/g)*ln(p2/p1);
	var sum_t = 0;
	var sum_p = 0;
	var p1 = 1000;
	var p2 = 500;
	var index_1000;
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if (tlinetest[0][0][i].press < 1000 && index_1000 == undefined) {
			index_1000 = i;
		}
		if(tlinetest[0][0][i].press == 1000){
			index_1000 = i;
		}else if(tlinetest[0][0][i].press < 500){
			index_500 = i;
		}
	}
	
	for(i=index_1000; i<index_500; i++){
		layer_t = (tlinetest[0][0][i].temp + tlinetest[0][0][i+1].temp) / 2;
		delta_p = tlinetest[0][0][i+1].press - tlinetest[0][0][i].press;
		sum_t += layer_t * delta_p;
		sum_p += delta_p;
	}
	Tbar = 273.15 + (sum_t / sum_p);
	delta_z = ((R * Tbar) / g) * Math.log(p1/p2);
	return Math.round(delta_z);
}

//this function assigns values for ppcl, tpcl, and tdpcl
function getParcelVals()
{
	//initialize vars
	var delta_p = 0;
	var fraction = 0;
	
	var mean_t = 0;
	var weighted_mean_t = 0;
	var t_range = 0;
	var t_interp = 0;
	
	var mean_td = 0;
	var weighted_mean_td = 0;
	var td_range = 0;
	var td_interp = 0;
			
	//start by getting the values at the lowest level
	var hi_p = tlinetest[0][0][0].press;
	//var temp0 = _parent.obs_array[_parent.obs_array.length-1].t;
	//var td0 = _parent.obs_array[_parent.obs_array.length-1].td;
	
	//now search upward and grab values for the next 100 mb up.
	//interpolate if necessary
	for(i=1; i<tlinetest[0][0].length; i++){
		if(hi_p - tlinetest[0][0][i].press <= 100){
			delta_p = tlinetest[0][0][i-1].press - tlinetest[0][0][i].press;
			mean_t = (tlinetest[0][0][i-1].temp + tlinetest[0][0][i].temp) / 2;
			weighted_mean_t += mean_t * delta_p;
			//same for dewpoint
			mean_td = (tlinetest[0][0][i-1].dwpt + tlinetest[0][0][i].dwpt) / 2;
			weighted_mean_td += mean_td * delta_p;
			//if we fall right on 100, then break out of for loop
// Maybe == isn't what is needed here... //
			if(hi_p - tlinetest[0][0][i].press == 100){
				break;	
			}
		}else{
			//interpolate the temp 100 mb above sfc
			fraction = (tlinetest[0][0][i-1].press - hi_p + 100) / (tlinetest[0][0][i-1].press - tlinetest[0][0][i].press);
			delta_p = tlinetest[0][0][i-1].press - (hi_p - 100);
			//interpolate temp
			t_range = (tlinetest[0][0][i].temp - tlinetest[0][0][i-1].temp);
			t_interp = (fraction * t_range) + tlinetest[0][0][i-1].temp;
			mean_t = (t_interp + tlinetest[0][0][i-1].temp) / 2;
			weighted_mean_t += mean_t * delta_p;
			//same for dewpoint
			td_range = (tlinetest[0][0][i].dwpt - tlinetest[0][0][i-1].dwpt);
			td_interp = (fraction * td_range) + tlinetest[0][0][i-1].dwpt;
			mean_td = (td_interp + tlinetest[0][0][i-1].dwpt) / 2;
			weighted_mean_td += mean_td * delta_p;
	//next 3 lines are obviously wrong...what are they for?		
			//_parent.p_pcl = _parent.obs_array[i].p
			//_parent.t_pcl = fraction;
			//_parent.td_pcl = delta_p;
			
			//break out of for loop
			break;
		}
	}
	ppcl = hi_p-bl_depth/2;
	tpcl = weighted_mean_t / bl_depth;
	tdpcl = weighted_mean_td / bl_depth;

	return [ppcl, tpcl, tdpcl];
}

function findLFCandEL(flag)
{
	if (flag == "ML") {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclPmix, tlinetest[0][0][0].lclTmix, tlinetest[0][0][0].lclTmix);
		tlinetest[0][0][0].thetaE_LCLmix = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclPmix,tlinetest[0][0][0].lclTmix);
		tlinetest[0][0][0].theta_LCLmix = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclPmix;
	} else {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclP, tlinetest[0][0][0].lclT, tlinetest[0][0][0].lclT);
		tlinetest[0][0][0].thetaE_LCL = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclP,tlinetest[0][0][0].lclT);
		tlinetest[0][0][0].theta_LCL = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclP;
	}
	//now find the observed temp at LCL by interpolation
	for(i=1; i<tlinetest[0][0].length; i++){
	//working from the bottom up, look for place where pressure is less than pressure at lcl
		p_lo = tlinetest[0][0][i].press;
		p_hi = tlinetest[0][0][i-1].press
		if (tlinetest[0][0][i].press < lcl_press){
			t_lo = tlinetest[0][0][i].temp;
			t_hi = tlinetest[0][0][i-1].temp;
			if (flag == "ML") {
				lcl_press = tlinetest[0][0][0].lclPmix;
				lcl_temp = tlinetest[0][0][0].lclTmix;
			} else {
				lcl_press = tlinetest[0][0][0].lclP;
				lcl_temp = tlinetest[0][0][0].lclT;
			}
			var start_index = i;
			break;
		}
	}


	var lfc_index = 999;

	//now interpolate to find the observed temp at the lcl
	fraction = (p_hi - lcl_press)/(p_hi - p_lo);
	obs_tlcl = t_hi - (fraction * (t_hi - t_lo));// + t_hi;
	//check if tlcl is greater than observed temp.
	//if so, lfc = lcl
	if(lcl_temp >= obs_tlcl){
		plfc = lcl_press;
		zlfc = tlinetest[0][0][0].lclZ;
		tlfc = Math.round(lcl_temp*10)/10;
		lfc_index = i;
	//otherwise start moving up the sounding from the lcl.
	//determine the parcel temp at each obs point, 
	//and check if parcel is greater than the obs temp.
	}else{
		var tempP_hi = tlinetest[0][0][start_index].press;
		var obsT_hi = tlinetest[0][0][start_index].temp;
		var obsZ_hi = tlinetest[0][0][start_index].hghtagl;
		var pclT_hi = findTC(thetae_lcl, tempP_hi);
		for (i=start_index; i<tlinetest[0][0].length-1; i++){
			tempP_lo = tlinetest[0][0][i].press;
			obsT_lo = tlinetest[0][0][i].temp;
			obsZ_lo = tlinetest[0][0][i].hghtagl;
			pclT_lo = findTC(thetae_lcl, tempP_lo);
			if (pclT_lo > obsT_lo) { 
				//NEW WAY: force to small number (0.1) if isothermal layer:
				if(obsT_hi - obsT_lo != 0){
					m_obs = (tempP_hi - tempP_lo) / (obsT_hi - obsT_lo);
				}else{
					m_obs = (tempP_hi - tempP_lo) / (0.1);
				}
				if(pclT_hi - pclT_lo != 0){
					m_pcl = (tempP_hi - tempP_lo) / (pclT_hi - pclT_lo);
				}else{
					m_pcl = (tempP_hi - tempP_lo) / (0.1);
				}
				if (m_obs == 0 &&  m_pcl == 0) {
					plfc = lcl_press;
					tlfc = lcl_temp;
					break;
				} 
				//now set up obs lines as ax + by = c
				a = m_obs;
				b = 1;
				c = (m_obs * obsT_hi) - tempP_hi;
				//set up parcel line as dx + ey = f
				d = m_pcl;
				e = 1;
				f = (m_pcl * pclT_hi) - tempP_hi;
				//now some linear algebra
				//find 3 determinates of matrices
				det1 = (a*e)-(b*d);
				det2 = (c*e)-(b*f);
				det3 = (a*f)-(c*d);
				//finally solve for plfc and tlfc
				tlfc = Math.round(det2/det1*10)/10;
				plfc = Math.round(-1*det3/det1);//not sure why the negative sign here, but it appears to work...
				zlfc = interpVal(plfc, tempP_lo, tempP_hi, obsZ_lo, obsZ_hi);
				break;
			}else{
				tempP_hi = tempP_lo;
				obsT_hi = obsT_lo;
				pclT_hi = pclT_lo;
				//what if there is NO LFC???
				if (i==1){
					plfc = -1;
				}
			}			
		}
		lfc_index = i;
	}
	//now find the EL by searching from the top down
	//determine the parcel temp at each obs point, 
	//and check if pcl t is greater than the obs t.
	var tempP_lo = 0;
	var obsT_lo = 0;
	var pclT_lo = 0;
	for (i=tlinetest[0][0].length-1; i>lfc_index; i--){
		tempP_hi = tlinetest[0][0][i].press;
		obsT_hi = tlinetest[0][0][i].temp;
		obsZ_hi = tlinetest[0][0][i].hghtagl;
		pclT_hi = findTC(thetae_lcl, tempP_hi);
		if(pclT_hi > obsT_hi){ 
			obsZ_lo = tlinetest[0][0][i].hghtagl;
			if(i==1){
				//not really any EL, so we assign the pel to the p at the top of the sounding
				pel = tempP_hi;
				tel = pclT_hi
			}else{
				//interpolate the pressure/temperature at the EL
				//slope m = rise over run
				if(obsT_hi - obsT_lo != 0){
					m_obs = (tempP_hi - tempP_lo) / (obsT_hi - obsT_lo);
				}else{
					m_obs = (tempP_hi - tempP_lo) / (0.1);
				}
				m_pcl = (tempP_hi - tempP_lo) / (pclT_hi - pclT_lo);
				//now set up obs lines as ax + by = c
				a = m_obs;
				b = 1;
				c = (m_obs * obsT_hi) - tempP_hi;
				//set up parcel line as dx + ey = f
				d = m_pcl;
				e = 1;
				f = (m_pcl * pclT_hi) - tempP_hi;
				//now some linear algebra
				//find 3 determinates of matrices
				det1 = (a*e)-(b*d);
				det2 = (c*e)-(b*f);
				det3 = (a*f)-(c*d);
				//finally solve for pel and tel
				tel = Math.round(det2/det1*10)/10;
				pel = Math.round(-1*det3/det1);//not sure why the negative sign here, but it appears to work...
				zel = interpVal(pel, tempP_lo, tempP_hi, obsZ_lo, obsZ_hi);
			}
			return [plfc, tlfc, zlfc, pel, tel, zel];
			break;
		}else{
			if(i==tlinetest[0][0].length){
				pel = 0;//never found an equil level
			}else{
				tempP_lo = tempP_hi;
				obsT_lo = obsT_hi;
				pclT_lo = pclT_hi;
			}
		}
	}

	return [plfc, tlfc, zlfc, pel, tel, zel];
}

function findTC(thetae, xp)
{
	//this function returns tempC for a given P and theta-e
	//it's used to find lfc, el, and cape
	var crit = 0.1;//criteria
	var eq0 = thetae;
	var eq1 = 0;
	var tlev = 10 - ((1000-xp)/10);
	//calc thetae for tlev and p
	for(k=0; k<100; k++){
		eq1 = calcThetaE(xp, tlev, tlev);
		diff = Math.abs(eq0-eq1);
		if(diff < 0.1){//close enough
			break;
		}else if(eq1>eq0){//our try (eq1) is larger than the obs theta-e (eq0)
			tlev = tlev - (diff/10);//so we subtract half the difference from tlev and try again
		}else{//otherwise, we add the difference 
			tlev = tlev + (diff/10);	
		}
	}
	return tlev;
}

function calcThetaE(P,t,dp)
{
	vp=calcVaporPressure(dp);//ambient vapor pressure
	w=calcMixingRatio(vp, P);
	tlclk = tlinetest[0][0][0].lclT+273.15;
	PT = (t + 273.15) * Math.pow(1000/P, 0.2854*(1-(0.00028*w)));
	EPTK = PT * Math.exp(((3.376/tlclk)-0.00254)*w*(1+(0.00081*w)));
	return Math.round(EPTK*10)/10;
}

function calcVaporPressure( temp )
{
	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(temp+273)));
	return vp;
}

function calcLI(t_parc_arr, t_obs_arr)
{
	for(i=0; i<t_parc_arr.length-1; i++) {
		if (tlinetest[0][0][i].press == 500) {
			var calc_li = t_obs_arr[i] - t_parc_arr[i];
			return Math.round(calc_li * 10)/10;
		} else if (tlinetest[0][0][i].press < 500) {
			var calc_li = t500 - interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, t_parc_arr[i], t_parc_arr[i-1]);
			return Math.round(calc_li * 10)/10;
		}
	}
}

//I developed this function to calc CAPE, and reuse it here.
// It was modified from an algo written by eric smith at csu,\
//I found it in a paper online by schlatter

function calcThetaE(P,t,dp)
{
	//var SP = parseFloat(P) * 1000.0;
	var ST = parseFloat(t) + 273.16;
	var SDP = parseFloat(dp) + 273.16;
	
	vp=calcVaporPressure(dp);//ambient vapor pressure
	w=calcMixingRatio(vp, P);
	//trace("w="+w+" at "+P+"mb");
	Tlcl = (1/(1/(SDP - 56) + Math.log (ST/SDP)/800)) + 56;//calc the temp at LCL
	PT = ST * Math.pow(1000/P, 0.2854*(1-(0.00028*w)));
	EPTK = PT * Math.exp((3.376/Tlcl-0.00254)*w*(1 + 0.00081 * w));
	return Math.round(EPTK*10)/10;
}

function calcZ(pres)
{
	//base = pres / 1013;
	//exp = 287 * .0065 / 9.8;
	base = pres / P0;
	exp = R * .0065 / g;
	temp_z = T0 / .0065 * (1 - Math.pow(base, exp));
	return Math.round(temp_z)
}

function getThickness(z){
	var psfc = tlinetest[0][0][0].press //p at sfc
	if(psfc >= 1000){
		thickness = Math.round(z);
	}else if(psfc < 1000){//sfc pressure is less than 1000, 
	//so extrapolate downward to 1000 mb using std atm lapse rate, 
	//but start at the first point above the sfc rather than the actual sfc.
	//first we actually have to subtract the thickness from the first to second points in the sounding
		sfc_index = 1;
		var t1 = getTv(tlinetest[0][0][sfc_index].temp, tlinetest[0][0][sfc_index].dwpt, tlinetest[0][0][sfc_index].press);
		var t2 = getTv(tlinetest[0][0][sfc_index+1].temp, tlinetest[0][0][sfc_index+1].dwpt, tlinetest[0][0][sfc_index+1].press);
		var Tbar = 273.15 + (t1+t2)/2;
		//second, retrieve the pressure at this level (i) and the next one up (i+1)
		var p1 = tlinetest[0][0][sfc_index].press;
		var p2 = tlinetest[0][0][sfc_index+1].press;
		//last, calculate the layer thickness
		layerz = ((R * Tbar) / g) * Math.log(p1/p2);
		z -= layerz;//subtract layer thickness from current sum (z)
	//now we have to get the thickness from the point above the sfc (t2, p2) down to 1000 mb
	//assume a lapse rate of 0.056 degrees / mb (=std atm from 900-1000 mb)
		var deltap = 1000 - p2;//delta-P from point above the sfc to 1000 mb
		var tvbark = t2 + (deltap * 0.056 / 2) + 273.15; //layer mean Tv (K),.056 degrees/mb from lapse rate of std atm at 900-1000 mb
		//calculate the layer thickness, add it to z
		layerz = ((R * tvbark) / g) * Math.log(1000/tlinetest[0][0][sfc_index+1].press);
		z += layerz;
		thickness = Math.round(z);
	}//station p greater than 1000, already handled in getBRN
}

function getTv(Tc,Tdc,p)
{
	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(Tdc+273)));
	mr = ((0.622*vp)/(p-vp))*1000.0;
	tv = Tc + (mr/6);
	return tv;
}

function convertFiletoJSON(data) {
	sdata = [];
	title_start = data.indexOf("<H2>");
	if (title_start == -1) {
		title_start = data.indexOf("<h2>");
	}
	title_start = title_start+4;
	title_end = data.indexOf("</H2>");
	if (title_end == -1) {
		title_end = data.indexOf("</h2>");
	}
	title = data.slice(title_start, title_end);

	start = data.indexOf("----------------------");
	start = data.indexOf("----------------------", start+77);
	end = data.indexOf("</PRE>");
	if (end == -1) {
		end = data.indexOf("</pre>");
	}

	var info = data.substring(end);
	data = data.substring(start+78, end);

	data_arr = data.split("\n");

	var n = 0;
	var obj = {};

	for (i=0; i < data_arr.length-1; i++) {
		if (data_arr[i].slice(0,7).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.press = Number(data_arr[i].slice(0,7)); 
		}
		if (data_arr[i].slice(7,14).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.hght = Number(data_arr[i].slice(7,14)); 
		}
		if (data_arr[i].slice(14,21).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.temp = Number(data_arr[i].slice(14,21)); 
		}
		if (data_arr[i].slice(21,28).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.dwpt = Number(data_arr[i].slice(21,28)); 
		}
		if (data_arr[i].slice(42,49).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.wdir = Number(data_arr[i].slice(42,49)); 
		}
		if (data_arr[i].slice(49,56).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.wspd = Number(data_arr[i].slice(49,56)); 
			obj.wspdround = Math.round(Number(data_arr[i].slice(49,56))/5) * 5;
		}
		sdata.push(obj); 
		obj = {};
	}

	lat_start = info.indexOf("latitude:");
	lat_start = lat_start+10;
	lat_end = lat_start+17;
	lat = parseFloat(info.slice(lat_start, lat_end));
	
	long_start = info.indexOf("longitude:");
	long_start = long_start+11;
	long_end = long_start+18;
	long = parseFloat(info.slice(long_start, long_end));

	return sdata;
}

function getLapseRate(tempArr, hghtArr, btmI, btmZ, dZ) {
	var sumLR = 0;
	var n=0;
	for (i=btmI; i<tempArr.length; i++) { 
		if (hghtArr[i]>hghtArr[btmI]+dZ) {
			break;
		}
		t_hi = tempArr[i];
		z_hi = hghtArr[i];
		t_lo = tempArr[i+1];
		z_lo = hghtArr[i+1];
		lr = (t_hi - t_lo) / ((z_hi - z_lo)/1000);
		sumLR += lr;
		n++;
	}
	var lapseRate = -sumLR/n;
	return lapseRate;
}

$(".x .tick").each( function() {
	var tickTran = $(this).attr("transform");
	tickTranX = tickTran.split(",");
	tickTranX = tickTranX[0].split("(");
	tickTranX = tickTranX[1]-14;
	tickTranY = tickTran.split(",");
	tickTranY = tickTranY[1].split(")");
	tickTranY = tickTranY[0]+8;
	$(this).attr("transform", "translate(" + tickTranX + " " + tickTranY + ") rotate(-" + tempSkew + ")");
});

</script>

</body>
</html>