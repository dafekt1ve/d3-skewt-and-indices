<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" media="screen" href="css/meted-base.min.css">
<link rel="stylesheet" type="text/css" media="screen" href="css/module-custom.css">
<link rel="stylesheet" type="text/css" href="sounding.css">
<title>Interactive Skew-T</title>
<body>

<div id="interaction-wrap">
<div id="container" style="padding-top: 50px;">
	
	<nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container center">
		<h2 id="title">Interactive Skew-T/Log-P Diagram </h2>
      </div>
	</nav>
	
	
	<div id="checks">
		<label for="parcel_check"><input id="parcel_check" type="checkbox" checked="checked">Parcel Temperature</input></label>
		<label for="parcelmix_check"><input id="parcelmix_check" type="checkbox" checked="checked">Mixed Parcel Temperature</input></label>
		<label for="tvc_check"><input id="tvc_check" type="checkbox" checked="checked">Virtual Temperature</input></label>
		<label for="twc_check"><input id="twc_check" type="checkbox" checked="checked">Wet Bulb Temperature</input></label>
		<br/>
		Mixing Layer Depth (in mb): 
		<input id="ml_depth" type="number" min="1" max="200" value="100" style="width: 50px">
		<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>For CAPE Calculations: 
		<label for="t_CAPE_check"><input name="CAPE_check" id="t_CAPE_check" type="radio" checked value="T">Use T</input></label>
		<label for="tv_CAPE_check"><input name="CAPE_check" id="tv_CAPE_check" type="radio" value="Tv">Use Tv</input></label>
	</div>
<div id="mainbox">
	<div id="checks_wrapper">
		<div id="upload_wrapper">
			<label id="fileUpload" for="input-file" class="btn btn-default btn_upload">Upload File</label>
			<input type="file" id="input-file" style="display:none;">
		</div>
		<div id="editData">
			<button id="editButton" class="btn btn-default" onClick="tableVis()">Show Current Data</button>
		</div>
		<div id="reset">
			<button id="resetSounding" class="btn btn-danger" onClick="resetSounding()">Reset Sounding</button>
		</div>
		<div id="undo_redo">
			<button id="undo" class="btn btn-default btn_undo" onClick="undo()">Undo</button>
			<button id="redo" class="btn btn-default btn_redo" onClick="redo()">Redo</button>
		</div>

		<div id="presets">
			<p>Preset Soundings:
				<select id="allstar_sounding">
					<option disabled>&#9473; Defaults &#9473;</option>
					<option value="data_TOP.json" default>Default Sounding</option>
					<option value="data_SkewT.json">Flash Sounding</option>
					<option disabled>&#9473; Thunderstorms &amp; Tornadoes &#9473;</option>
						<option value="./All-Star-Soundings/BMX_2011427_18.html">Tornado Outbreak (BMX)</option>
						<option value="./All-Star-Soundings/BMX_2011428_00.html">Tornado Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/TOP_200354_12.html'>Tornado Outbreak (TOP)</option>
						<option value='./All-Star-Soundings/TOP_200354_18.html'>Tornado Outbreak (TOP)</option>
						<option value='./All-Star-Soundings/TOP_200355_00.html'>Tornado Outbreak -- Post Dryline (TOP)</option>
						<option value='./All-Star-Soundings/OUN_200358_12.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_200358_18.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_200359_00.html'>Moore, OK Tornado (OUN)</option>
						<option value='./All-Star-Soundings/TOP_2004530_00.html'>NE/KS/OK Tornadoes (TOP)</option>
						<option value='./All-Star-Soundings/OUN_2004530_00.html'>NE/KS/OK Tornadoes (OUN)</option>
						<option value='./All-Star-Soundings/BMX_2011427_18.html'>Severe Weather Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/BMX_2011428_00.html'>Severe Weather Outbreak (BMX)</option>
						<option value='./All-Star-Soundings/JAN_2011427_18.html'>Severe Weather Outbreak (JAN)</option>
						<option value='./All-Star-Soundings/OUN_2011524_12.html'>Severe Weather Outbreak (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2011524_18.html'>Severe Weather Outbreak (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013520_12.html'>Moore, OK EF5 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013520_18.html'>Moore, OK EF5 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/OUN_2013531_12.html'>El Reno, OK EF3 Tornado (OUN)</option>
						<option value='./All-Star-Soundings/FGZ_2017820_00.html'>Dry Microburst (FGZ)</option>
						<option value='./All-Star-Soundings/OUN_2015615_00.html'>Wet Microburst (OUN)</option>
						<option value='./All-Star-Soundings/IAD_2012630_00.html'>Derecho (IAD)</option>
					<option disabled>&#9473; Hurricanes &#9473;</option>
						<option value='./All-Star-Soundings/EYW_2004813_00.html'>Hurricane Charley (EYW)</option>
						<option value='./All-Star-Soundings/EYW_2004813_12.html'>Hurricane Charley (EYW)</option>
						<option value='./All-Star-Soundings/TBW_2004813_18.html'>Hurricane Charley (TBW)</option>
						<option value='./All-Star-Soundings/TBW_2004814_00.html'>Hurricane Charley (TBW)</option>
						<option value='./All-Star-Soundings/CRP_2003716_00.html'>Hurricane Claudette (Near Landfall; CRP)</option>
						<option value='./All-Star-Soundings/DRT_2003716_00.html'>Hurricane Claudette (Inland Dry Environment; DRT)</option>
						<option value='./All-Star-Soundings/DRT_2003716_06.html'>Hurricane Claudette (Inland Moistening Environment; DRT)</option>
						<option value='./All-Star-Soundings/DRT_2003716_12.html'>Hurricane Claudette (Inland over DRT; DRT)</option>
						<option value='./All-Star-Soundings/76595_2002923_12.html'>Hurricane Isidore (76595)</option>
						<option value='./All-Star-Soundings/MMMD_2002922_12.html'>Hurricane Isidore (MMMD)</option>
						<option value='./All-Star-Soundings/LIX_2005827_06.html'>Hurricane Katrina (LIX)</option>
						<option value='./All-Star-Soundings/LZK_2005830_00.html'>Remnants of Hurricane Katrina (LZK)</option>
						<option value='./All-Star-Soundings/TXKF_20141018_12.html'>Hurricane Gonzalo (direct hit on Bermuda; TXKF)</option>
						<option value='./All-Star-Soundings/JAX_20161008_00.json'>Hurricane Matthew (JAX)</option>
						<option value='./All-Star-Soundings/CRP_2017826_00.html'>Hurricane Harvey (Near Landfall; CRP)</option>
						<option value='./All-Star-Soundings/EYW_2017910_00.html'>Hurricane Irma (12 hrs prior to landfall; EYW))</option>
						<option value='./All-Star-Soundings/TBW_2017911_00.html'>Hurricane Irma (12 hrs post landfalll TBW)</option>
					<option disabled>&#9473; Heavy Snow &#9473;</option>
						<option value="./All-Star-Soundings/ABR_20051129_00.html">Heavy Snow (ABR)</option>
						<option value='./All-Star-Soundings/BUF_20011224_12.html'>Heavy Lake Effect Snow (BUF)</option>
						<option value='./All-Star-Soundings/BUF_20011225_00.html'>Heavy Lake Effect Snow (BUF)</option>
						<option value='./All-Star-Soundings/OUN_20021223_18.html'>Heavy Snow/Thundersnow</option>
						<option value='./All-Star-Soundings/FWD_2004213_12.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004214_00.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004214_12.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/FWD_2004215_00.html'>Heavy Snow</option>
						<option value='./All-Star-Soundings/ABR_20051129_00.html'>Winter Storm</option>
						<option value='./All-Star-Soundings/OKX_2006212_06.html'>Historic Blizzard</option>
						<option value='./All-Star-Soundings/CHH_2006212_06.html'>Historic Blizzard</option>
						<option value='./All-Star-Soundings/LBF_2006321_00.html'>Great Plains Snowstorm</option>
						<option value='./All-Star-Soundings/OAX_2006321_00.html'>Great Plains Snowstorm</option>
						<option value='./All-Star-Soundings/BUF_20131212_00.html'>Heavy Lake Effect Snow</option>
						<option value='./All-Star-Soundings/CHH_2015127_12.html'>Boston Blizzard</option>
						<option value='./All-Star-Soundings/BUF_20141119_00.html'>Heavy Lake Effect Snow</option>
						<option value='./All-Star-Soundings/GYX_2015128_00.html'>Blizzard</option>
						<option value='./All-Star-Soundings/TFX_2019929_12.html'>4 Feet of Snow</option>
					<option disabled>&#9473; Heavy Rain/Flooding &#9473;</option>
						<option value='./All-Star-Soundings/FWD_2004728_00.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FWD_2004728_12.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FWD_2004729_00.html'>Heavy Rain</option>
						<option value='./All-Star-Soundings/FFC_2009920_12.html'>Atlanta Flash Flood</option>
						<option value='./All-Star-Soundings/OUN_2010614_00.html'>Oklahoma City Flash Flood</option>
						<option value='./All-Star-Soundings/OUN_2010614_12.html'>Oklahoma City Flash Flood</option>
						<option value='./All-Star-Soundings/OKX_2014813_12.html'>Historic Flooding on Long Island</option>
						<option value='./All-Star-Soundings/DNR_2013912_12.html'>Historic Flooding along Front Range of Colorado</option>
						<option value='./All-Star-Soundings/DNR_2013913_12.html'>Historic Flooding along Front Range of Colorado</option>
					<option disabled>&#9473; Precipitation Typing &#9473;</option>
						<option value='./All-Star-Soundings/FWD_20001213_12.html'>Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/OUN_20001213_12.html'>Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/FWD_20001226_00.html'>Rain/Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/OUN_20001226_00.html'>Rain/Freezing Rain/Ice Pellets</option>
						<option value='./All-Star-Soundings/GSO_200821_12.html'>Cold Air Damming</option>
					<option disabled>&#9473; Heat Wave &#9473;</option>
						<option value='./All-Star-Soundings/OUN_2003721_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/OUN_201183_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/FWD_201183_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/DVN_1995714_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/ILX_1995714_00.html'>Heat Wave</option>
						<option value='./All-Star-Soundings/NKX_201877_00.html'>Heat Wave</option>
					<option disabled>&#9473; Cold Wave &#9473;</option>
						<option value='./All-Star-Soundings/PABR_2002110_00.html'>Large Inversion/Low Tropopause</option>
						<option value='./All-Star-Soundings/OAX_201417_12.html'>Arctic Cold Blast (Record-setting Surface High)</option>
						<option value='./All-Star-Soundings/UIL_201427_12.html'>Seattle Record Cold</option>
						<option value='./All-Star-Soundings/MPX_199622_12.html'>Frigid Cold</option>
						<option value='./All-Star-Soundings/ABR_20140106_00.html'>Brutal Cold</option>
					<option disabled>&#9473; Wildfire &#9473;</option>
						<option value='./All-Star-Soundings/MFR_2018727_00.html'>Carr Wildfire</option>		
				</select>
<!--			<button id="default" onClick="loadSounding()" value="default">Load Sounding</button>-->
			</p>
			<p id="link-set">
				<a href="upload_instructions.htm" class="fbox-res-iframe" target="_blank"><span class="glyphicon glyphicon-link"></span> Upload File Instructions</a><br>
				<a href="https://www.meted.ucar.edu/mesoprim/skewt/" target="_blank"><span class="glyphicon glyphicon-link"></span> <em>Skew-T Mastery</em> lesson</a>
			</p>
		</div>
	</div>
</div>
<div id="hodobox"><div id="indicesWindow"></div></div>
<div id="editTableWrap"></div>
<p id="copyright">&copy; The COMET Program</p>
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>
<script src="./jquery/jquery-3.4.1.min.js"></script>
<script src="jquery/jquery-ui.min.js"></script>
<script src="jquery/jquery-plugins.min.js"></script>
<link rel="stylesheet" type="text/css" media="screen" href="jquery/apps/fancybox/fancybox.min.css">
<script type="text/javascript" src="jquery/apps/fancybox/fancybox.min.js"></script>
<script src="jsfunctions.js"></script>
<script type="text/javascript">

$(document).ready( function() {	
	$(window).keydown(function(event){
		if(event.keyCode == 13) {
		event.preventDefault();
		return false;
		}
	  });

	$("input:checkbox").on('change', function () {
		plotChecks();
	});

	$("#undo").prop("disabled", true);
	$("#redo").prop("disabled", true);

	$("#ml_depth").on("input", function () {
		bl_depth = parseFloat($(this).val());
		drawSkew();
		drawText();
		tabulate("editTable", columns, tlinetest[0][0],true);
	});

	$("input:radio[name='CAPE_check']").on("change", function() {
		drawSkew();
		drawText();
	});

	$("#allstar_sounding").change(function () {
		loadSounding();
	});

});

function plotChecks() {
	var className;
	$('input:checkbox').each(function() {
		className = $(this).prop('id');
		className = className.split("_",1).toString();
		if (!$(this).is(":checked")) {
			$("." + className + ".member").css("visibility", "hidden");
			$("." + className + ".focus").css("visibility", "hidden");
		} else {
			$("." + className + ".member").css("visibility", "visible");
			$("." + className + ".focus").css("visibility", "visible");;
		}
	});
	if(className == "twc") {
		$(".wbztext, .wbz_rectline").css('visibility', $(".wbztext, .wbz_rectline").css('visibility') == 'hidden' ? 'visible' : 'hidden');
		drawSkew();
		drawText();
		tabulate("editTable", columns, tlinetest[0][0],true);
	} else if (className == "tvc") {
		drawSkew();
		drawText();
		tabulate("editTable", columns, tlinetest[0][0],true);
	} else if (className == "parcel") {
		$(".lcltext, .lcl, .lfctext, .lfc, .eltext, .el").css('visibility', $(".lcltext, .lcl, .lfctext, .lfc, .eltext, .el").css('visibility') == 'hidden' ? 'visible' : 'hidden');
		drawSkew();
		drawText();
		tabulate("editTable", columns, tlinetest[0][0],true);
	} else if (className == "parcelmix") {
		$(".lclmixtext, .lclmix, .lfcmixtext, .lfcmix, .elmixtext, .elmix").css('visibility', $(".lclmixtext, .lclmix, .lfcmixtext, .lfcmix, .elmixtext, .elmix").css('visibility') == 'hidden' ? 'visible' : 'hidden');
		drawSkew();
		drawText();
		tabulate("editTable", columns, tlinetest[0][0],true);
	} else {
	}
}

var loadedPreset = true;
var loadedFile = false;

var lat, long;
var columns = ['press', 'temp', 'dwpt', 'wdir', 'wspd'];


function tableVis () {
	$("#editTableWindow").toggle();
	//if ($("#editTableWrap").is(":visible")) {
	
	if ($("#editTableWindow").is(":visible")) {
		$("#editButton").text("Hide Current Data");
	} else {
		$("#editButton").text("Show Current Data");
	}
	tabulate("editTable", columns, tlinetest[0][0], true);
}

function tabulate(tabName, headers, data, editFlag) {
	d3.select("#" + tabName + "Window").html("");
	var columnLabels = ['Pressure (hPa)', 'Temperature (°C)', 'Dewpoint (°C)', 'Wind Direction (°)', 'Wind Speed (kt)'];
	var table = d3.select('#' + tabName + 'Window').append('table').attr("id",tabName).attr("class", "table table-responsive table-bordered table-striped drag-cancel");
		//table.append('div').attr('class', 'drag-instructions').text('Click and drag this window to move it around; click on the values to edit them.');
	
	var thead = table.append('thead');
	var	tbody = table.append('tbody');

	if (tabName === 'editTable') {
	// append the header row
	thead.append('tr')
	  .selectAll('th')
	  .data(columnLabels).enter()
	  .append('th')
	    .text(function (column) { return column; });
	}
	else {
	// append the header row
	thead.append('tr')
	  .selectAll('th')
	  .data(headers).enter()
	  .append('th')
	    .text(function (column) { return column; });
	}
	

	// create a row for each object in the data
	var rows = tbody.selectAll('tr')
	  .data(data)
	  .enter()
	  .append('tr');

	// create a cell in each row for each column
	var cells = rows.selectAll('td')
	  .data(function (row) {
		return headers.map(function (column) {
	      return {column: column, value: row[column]};
	    });
	  })
	  .enter()
	  .append('td')
	  .attr("contenteditable", editFlag)
	  .text(function (d) { return d.value; });

	rows.selectAll(":first-child").attr("contenteditable", "false");
	
	if (editFlag) {
		rows.selectAll().attr("class", "edit");
		//table.append('div').attr('class', 'drag-instructions').text('Click and drag this window to move it around; click on the values to edit them.');
	}

	$("#editTable [contenteditable=true]").on("input", function() {
		var row = $(this).parent().children();
		var i = $("#editTable tr:not(:first)").index($(this).parent());
		var j = $(this).parent().children("td").index(this);
   		update(row, i, j);
	});

  return table;
}

function update(r, i, j) {
	var here = $("#editTable tr:not(:first)").eq(i).children("td").eq(j);
	var inputText = r.eq(j).text().trim();
	console.log(inputText);

	var signs = /^[-+.]?[.]?$/;
	var numbers = /^[-+]?[0-9]*\.?[0-9]+$/;

	if (j%4 == 1 || j%4 == 2) {
		if (inputText.match(signs)) {
			return false
		}
	}

	if (inputText == "") {
		here.addClass("blank");
		return false
	} else if (inputText.match(numbers)) {
		if (j == 1) {
			tlinetest[0][0][i].temp = parseFloat(inputText);
			if (tlinetest[0][0][i].temp < tlinetest[0][0][i].dwpt) {
				// Send error message to user to correct temp and dwpt
				here.addClass("blank");
				here.next().addClass("blank");
				return false
			} else {
				here.removeClass("blank");
				here.next().removeClass("blank");
			}
		} else if (j == 2) {
			tlinetest[0][0][i].dwpt = parseFloat(inputText);
			if (tlinetest[0][0][i].dwpt > tlinetest[0][0][i].temp) {
				// Send error message to user to correct temp and dwpt
				here.addClass("blank");
				here.prev().addClass("blank");
				return false
			} else {
				here.removeClass("blank");
				here.prev().removeClass("blank");
			}
		} else if (j == 3) {
			if (inputText.match(/^\d*\.?\d+$/)) {
				if (parseFloat(inputText) > 360 || parseFloat(inputText) < 0 ) {
					var howLarge = parseFloat(inputText)/360;
					if (howLarge < 1 && howLarge > 0) {
						var direct = parseFloat(inputText);
					} else if (howLarge < 0 && howLarge > -1) {
						var direct = parseFloat(inputText) + 360;
					} else if (Math.abs(howLarge) >= 1) {
						var multiplier = Math.floor(howLarge);
						var direct = parseFloat(inputText) - 360*multiplier;
					}
					here.text(direct);
				}
				tlinetest[0][0][i].wdir = parseFloat(inputText);
			} else {
				here.text(tlinetest[0][0][i].wdir);
				return false;
			}
		} else if (j == 4) {
			if (inputText.match(/^\d*\.?\d+$/)) {
				tlinetest[0][0][i].wspd = parseFloat(inputText);
				tlinetest[0][0][i].wspdround = Math.round((parseFloat(inputText)/5))*5;
			} else {
				here.text(tlinetest[0][0][i].wspd);
				return false;
			}

		}
	} else {
		if (j == 1) {
			here.text(tlinetest[0][0][i].temp);
		} else if (j == 2) {
			here.text(tlinetest[0][0][i].dwpt);
		} else if (j == 3) {
			here.text(tlinetest[0][0][i].wdir);
		} else if (j == 4) {
			here.text(tlinetest[0][0][i].wspd);	
		}
		return false;
	}
	here.removeClass("blank");
	drawSkew();
	drawText();
}

$("input[type='file']").on("change", function () {
	loadedFile = true;
	loadFile();
	loadedPreset = false;
});

function loadFile() {
	loadedPreset = false;
	const reader = new FileReader();
	reader.readAsText(document.querySelector('input[type="file"]').files[0]);
	reader.onload = () => storeResults(reader.result);
	loadedFile = true;
	undoArr = [];
	redoArr = [];
	$("#undo").prop("disabled", false);
	$("#redo").prop("disabled", false);
}

function storeResults(result) {
	sounding = result;
	jsonObj = convertFiletoJSON(sounding);
	dataParse();
}

function loadSounding () {
	loadedFile = false;
	var soundingFile = $('#allstar_sounding').children('option:selected').val();
	$(".focusgroup").empty();
	title = "";
	if (soundingFile.includes(".html")) {
		getHTMLSounding(soundingFile);
	} else if (soundingFile.includes(".json")) {
		dataParse(soundingFile);
	}
	loadedPreset = true;
	undoArr = [];
	redoArr = [];
	$("#undo").prop("disabled", true);
	$("#redo").prop("disabled", true);
}

var sounding = '';

function getHTMLSounding(filename) {
	var dataRead = fetch(filename)
		.then(response => response.blob())
		.then(function(myBlob) {
			const reader = new FileReader();
			reader.readAsText(myBlob);
			reader.onload = () => storeResults(reader.result);
		});
	undoArr = [];
	redoArr = [];
	$("#undo").prop("disabled", true);
	$("#redo").prop("disabled", true);
}

function resetSounding() {
	undoArr = [];
	redoArr = [];
	$("#undo").prop("disabled", true);
	$("#redo").prop("disabled", true);
	
	if (loadedFile) {
		loadFile();
		return;
	}
	if (loadedPreset) {
		loadSounding();
		return;
	}
}

var undoArr = [];
var redoArr = [];

function undo() {
	p = undoArr[0].index;
	var redoObj = {
		"index": p,
		"press": tlinetest[0][0][p].press,
		"temp": tlinetest[0][0][p].temp,
		"dwpt": tlinetest[0][0][p].dwpt,
		"wdir": tlinetest[0][0][p].wdir,
		"wspd": tlinetest[0][0][p].wspd,
		"wspdround": tlinetest[0][0][p].wspdround
	}
	redoArr.unshift(redoObj);
	$("#redo").prop("disabled", false);

	tlinetest[0][0][p].temp = undoArr[0].temp;
	tlinetest[0][0][p].dwpt = undoArr[0].dwpt;
	tlinetest[0][0][p].wspd = undoArr[0].wspd;
	tlinetest[0][0][p].wdir = undoArr[0].wdir;
	tlinetest[0][0][p].wspdround = undoArr[0].wspdround;
	drawSkew();
	drawText();
	tabulate("editTable", columns, tlinetest[0][0],true);
	undoArr.shift();

	if (typeof undoArr[0] == 'undefined') {
		$("#undo").prop("disabled", true);
	}
}

function redo() {
	p = redoArr[0].index;
	undoObj = {
		"index": p,
		"press": tlinetest[0][0][p].press,
		"temp": tlinetest[0][0][p].temp,
		"dwpt": tlinetest[0][0][p].dwpt,
		"wdir": tlinetest[0][0][p].wdir,
		"wspd": tlinetest[0][0][p].wspd,
		"wspdround": tlinetest[0][0][p].wspdround
	}
	undoArr.unshift(undoObj);
	$("#undo").prop("disabled", false);

	tlinetest[0][0][p].temp = redoArr[0].temp;
	tlinetest[0][0][p].dwpt = redoArr[0].dwpt;
	tlinetest[0][0][p].wspd = redoArr[0].wspd;
	tlinetest[0][0][p].wdir = redoArr[0].wdir;
	tlinetest[0][0][p].wspdround = redoArr[0].wspdround;
	drawSkew();
	drawText();
	tabulate("editTable", columns, tlinetest[0][0],true);
	redoArr.shift();

	if (typeof redoArr[0] == 'undefined') {
		$("#redo").prop("disabled", true);
	}
}

//some constants from meted.ucar.edu/awips/validate
var R = 287.04; // J/Kg K--gas constant
var Cp = 1004; // J/Kg K--specific heat at constant pressure
var g = 9.80665;
var c5 = -0.37329638;
var c6 = 41.178204;
var c7 = 0.0015945203;
var c10 = 0.1419709;
var c11 = 20.746475;
var c12 = 6672.5713;
var c13 = .000036336427;
var T0 = 288.15;
var P0 = 1013.25;

var jsonObj;
var sdata = new Array();
var data_arr = [];
var filtered = [];
var title = '';
var labels = [];

var ppcl = 0;//pressure for parcel to be lifted
var tpcl = 0;//temp for parcel to be lifted (C)
var tdpcl = 0; //dewpoint for parcel to be lifted
var plcl = 0; //pres at LCL
var tlcl = 0; //temp at LCL
var plfc = -1; //pressure at LFC
var tlfc = 0; //temp at LFC 
var pel = 0; //pressure at EL
var tel = 0; //tempC at EL
var thetae_lcl = 0;//theta-e at LCL
var pccl = 0; //pres at ccl - set in calcCCL()
var tccl = 0; //temp at ccl - set in calcCCL(), used by calcConvTemp()
var p_pcl100 = 0;//_parent.capeMC.ppcl
var t_pcl100 = 0;//_parent.capeMC.tpcl
var td_pcl100 = 0;//_parent.capeMC.tdpcl
var parcel_temp = 0;
var parcel_temp_array = new Array();
var pcl_t_arr = new Array();
var ml_pcl_t_arr = new Array();
var parcel_flag = 0;
var cin_parcelT = 0;
var cin_parcelT_array = new Array();
var cin_parcelT_below_LCL_array = new Array();
var pcl_cin_t_arr = new Array();
var pcl_cin_t_below_LCL_arr = new Array();
var bl_depth = 100;

var t500 = 0; //temp(C) at 500 mb
var ws500 = 0; //windspeed at 500 mb
var wd500 = 0; //wind direction at 500 mb
var t700 = 0; //temp at 700(C) mb
var td700 = 0; //dewpoint at 700(C)
var t850 = 0; //temp(C) at 850 mb
var td850 = 0; //dewpoint at 850(C)
var ws850 = 0; //windspeed at 850 mb
var wd850 = 0; //wind direction at 850 mb
var t1000 = 0; //temp(C) at 1000 mb
var td1000 = 0; //dewpoint at 1000(C)
var ws1000 = 0; //windspeed at 1000 mb
var wd1000 = 0; //wind direction at 1000 mb
var flag_1000 = 0;
var flag_850 = 0;
var flag_700 = 0;
var flag_500 = 0;
var tk = 0; //temp (K)
var tdk = 0; //dewpoint (K)
var p_sfc = 0;
var t_sfc = 0;
var td_sfc = 0;

var m = [30, 40, 20, 35],
    width = 700 - m[1] - m[3],
    height = 700 - m[0] - m[2];

var d2r = (Math.PI/180);
var tempSkew = 55;
var tan = Math.tan(tempSkew*d2r),
    basep = 1050,
    topp = 100,
    plines = [1000,925,850,700,600,500,400,300,200,100]
    pticks = [950,900,800,750,650,600,550,450,400,350,250,150];
	barbsize = 25;

// Scales and axes. Note the inverted domain for the y-scale: bigger is up!
var x = d3.scale.linear().range([0, width]).domain([-45,50]),
    y = d3.scale.log().range([0, height]).domain([topp, basep])
    r = d3.scale.linear().range([0,300]).domain([0,150]),
    y2 = d3.scale.linear(),
    xAxis = d3.svg.axis().scale(x).tickSize(0,0).ticks(10).orient("bottom"),
    yAxis = d3.svg.axis().scale(y).tickSize(0,0).tickValues(plines)
              .tickFormat(d3.format(".0d")).orient("left")
	yAxis2 = d3.svg.axis().scale(y).tickSize(5,0).tickValues(pticks).orient("right"); // just for ticks

// various path generators
var line = d3.svg.line()
    .interpolate("linear")
    .x(function(d,i) { return x(d.temp) + (y(basep)-y(d.press))/tan; })
    .y(function(d,i) { return y(d.press); });
    
var line2 = d3.svg.line()
    .interpolate("linear")
    .x(function(d,i) { return x(d.dwpt) + (y(basep)-y(d.press))/tan; })
    .y(function(d,i) { return y(d.press); });

var hodoline = d3.svg.line.radial()
    .radius(function(d) { return r(d.wspd); })
	.angle(function(d) { return (d.wdir+180)*(Math.PI/180); });
    
// bisector function for tooltips    
var bisectTemp = d3.bisector(function(d) { return d.press; }).left;

// create svg container for sounding
var svg = d3.select("div#mainbox").insert("svg", ":first-child")
      .attr("width", width + m[1] + m[3])
	  .attr("height", height + m[0] + m[2])
	  .attr("id","box")
    .append("g")
		  .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
    
var titleText = d3.select("div#mainbox svg").append("svg").attr("class", "title").attr("width", 700).attr("height", 40).append("text").attr("class", "titleText");      

// create svg container for hodograph
var svghodo = d3.select("div#hodobox").insert("svg",":first-child")
      .attr("width", 360)
      .attr("height", 300)
	  .append("g")
	  .attr("class","hodosvg")
	  .attr("transform", "translate(150,150)");
	  
	hodofocus = svghodo.append("g")
		.attr("class","hodogroup")
		.append("line")
		.attr("class","focus hodarrow")
		.attr("x1", "0")
		.attr("y1", "0")
		.attr("stroke-width","2")
		.attr("marker-end","url(#arrowhead)")
		.style("display","none");

	d3.select(".hodogroup")
		.append("circle")
		.attr("r", "6px")
		.attr("fill", "cyan")
		.attr("stroke", "black")
		.attr("opacity",".6")
		.style("display", "none")
		.attr("class", "focus hod");
      
/*var svgtext = d3.select("div#hodobox").append("svg").attr("class", "indices").attr("width", 320).attr("height", 400)
			.append("g").attr("transform", "translate(0,50)");*/


makeBarbTemplates();
drawBackground();
drawTextLabels();

var skewtgroup = svg.append("g").attr("class", "skewt"); // put skewt lines in this group
var barbgroup  = svg.append("g").attr("class", "windbarb"); // put barbs in this group
var hodogroup = svghodo.append("g").attr("class", "hodo"); // put hodo stuff in this group
var membergroup = skewtgroup.append("g").attr("class", "membergroup"); // put member lines in this group
var labelgroup = skewtgroup.append("g").attr("class", "labelgroup"); // put labels in this group
var focusgroup = skewtgroup.append("g").attr("class", "focusgroup"); // put focus dots in this group

var hodobarbstest = [];

if(/[?&]ls=/.test(location.search)) {
	var ls = location.search;
	ls = ls.replace('?ls=',"");
	ls = ls.replace('&ls=',"");
	console.log(ls);
	dataParse(ls);
} else {
	dataParse('data_TOP.json'); // 2003 Jun 24 00Z
}

function dataParse(fileName) {

	hodobarbstest = [], tlinetest = [], interpdots = [], barbstest = [], flattened = [];
	var hr=0;
	var temp = [], temp2 = [], temp3 = [];
	var mem = 0;
	
	if (fileName) {	
		d3.json(fileName, function(err, json) {
				parseDataNew(json);
	
	       		parsedCSV = alldata[mem][hr].filter(function(d) { return (d.temp > -1000 && d.dwpt > -1000); });
	       		barbs = parsedCSV.filter(function(d) { return (d.wdir >= 0 && d.wspd >= 0 && d.press >= topp); });
	       		hodobarbs = barbs.filter(function(d) { return (d.press >= 100); });
	        	interpdot = interpobjects[hr + 49*mem];
	
		        temp.push(hodobarbs);
	       		temp2.push(parsedCSV);
	        	temp3.push(barbs);
	        	interpdots.push(interpdot);
	        	hodobarbstest.push(temp);
	        	tlinetest.push(temp2);
	        	barbstest.push(temp3);
	
		    // need this for dots for some reason
		    mouseoverdata = tlinetest[0][0].slice(0).reverse();
			flattened = interpdots.reduce(function(a,b) { return a.concat(b); });
			drawSkew();
			drawText();
			drawToolTips();
			tabulate("editTable", columns, tlinetest[0][0],true);
		});
	} else {
		alldata=[[sdata]];
	       	parsedCSV = alldata[mem][hr].filter(function(d) { return (d.temp > -1000 && d.dwpt > -1000); });
	       	barbs = parsedCSV.filter(function(d) { return (d.wdir >= 0 && d.wspd >= 0 && d.press >= topp); });
	       	hodobarbs = barbs.filter(function(d) { return (d.press >= 100); });


		var hAGL;
		var test = [];
		interpobjects = [];
		test.push(parsedCSV[0]);
		for (j=1; j< requestedLevels.length; j++) {
			hAGL = requestedLevels[j]*1000+parsedCSV[0].hght;
			for (i=1; i<parsedCSV.length; i++) {
				if (parsedCSV[i].hght > hAGL) {
					var interp = d3.interpolateObject(parsedCSV[i-1],parsedCSV[i]);
							var half = interp(1-(hAGL - parsedCSV[i].hght)/(parsedCSV[i-1].hght - parsedCSV[i].hght));
							test.push(half);
					break;
				}
			};
		};

		interpobjects.push(test);

	        interpdot = interpobjects[hr + 49*mem];
	
		temp.push(hodobarbs);
	       	temp2.push(parsedCSV);
	        temp3.push(barbs);
	        interpdots.push(interpdot);
	        hodobarbstest.push(temp);
	        tlinetest.push(temp2);
	        barbstest.push(temp3);
	
	// need this for dots for some reason
		mouseoverdata = tlinetest[0][0].slice(0).reverse();
		flattened = interpdots.reduce(function(a,b) { return a.concat(b); });

		for (i=0; i<tlinetest[0][0].length ; i++) {
			if (i==0) {
				var height0 = tlinetest[0][0][0].hght;
			}
			tlinetest[0][0][i].hghtagl = tlinetest[0][0][i].hght - height0;
		}

		d3.selectAll("g.focusgroup > *").remove();
		d3.selectAll("g.membergroup > *").remove();
		d3.selectAll("g.labelgroup > *").remove();
		d3.selectAll("g.windbarb > *").remove();
		d3.selectAll("g.hodo > *").remove();
		makeBarbTemplates();
		drawSkew();
		drawText();
		drawToolTips();
		tabulate("editTable", columns, tlinetest[0][0],true);
	}
}

function interpDots(data) { 
	var hAGL;
	var test = [];
	var interpdot = [];
	interpdots = [];
	interpobjects = [];
	flattened = [];
	test.push(data[0][0][0]);
	for (j=1; j< requestedLevels.length; j++) {
		hAGL = requestedLevels[j]*1000+data[0][0][0].hght;
		for (i=1; i<data[0][0].length; i++) {
			if (data[0][0][i].hght > hAGL) {
				var interp = d3.interpolateObject(data[0][0][i-1],data[0][0][i]);
						var half = interp(1-(hAGL - data[0][0][i].hght)/(data[0][0][i-1].hght - data[0][0][i].hght));
						test.push(half);
				break;
			}
		};
	};

	interpobjects.push(test);
	interpdot = interpobjects[0];
	interpdots.push(interpdot);
	flattened = interpdots.reduce(function(a,b) { return a.concat(b); });

	return (flattened);
}

function parseDataNew(json) {
    requestedLevels = [0,1,3,6,9]; // levels in km agl
	interpobjects = [];
	alldata = json['tmpc'].map(function(c,k) {
		return c.map(function(d,i) {
			var obj = d.map(function(e,j) {
				return {
					press: +json.pres[k][i][j],
					hght: +json.hght[k][i][j],
					temp: +json.tmpc[k][i][j],
					dwpt: +json.dwpt[k][i][j],
					wdir: +json.wdir[k][i][j],
					wspd: +json.wspd[k][i][j],
					hghtagl: +json.hght[k][i][j] - +json.hght[k][i][0],
					wspdround: Math.round((json.wspd[k][i][j])/5) * 5
			}
			});
			
			// interpolate to given heights for each sounding
			var test = requestedLevels.map(function(d) {
				if (d == 0) { return obj[0]; }
				d = 1000*d+obj[0].hght; // want height AGL
				for (i=0; i<=obj.length; i++) {
					if (obj[i].hght > d) { var closeindex = i; break; } // since hghts increase monotonically
				}
				var interp = d3.interpolateObject(obj[i-1],obj[i]); // interp btw two levels
				var half = interp(1-(d - obj[i].hght)/(obj[i-1].hght - obj[i].hght));
				return half
			});
			interpobjects.push(test);
			return obj;
		});
	});
	return alldata;
}
       
function makeBarbTemplates() {
    var speeds = d3.range(0,205,5);
	barbdef = svg.append('defs')

	barbdef.append("g")
		.attr("id","speedRect")
	d3.select("#speedRect")
		.append("rect").attr("width", "35").attr("height", "15").attr("transform","translate(0,-2)");
	d3.select("#speedRect")
		.append("line").attr("x1", "0").attr("x2", "30").attr("y1", "7.5").attr("y2","7.5").attr("transform","translate(35,-2)");
	d3.select("#speedRect")
		.append("circle").attr("r","4").attr("transform","translate(65,5.5)");

    speeds.forEach(function(d) {
    	var thisbarb = barbdef.append('g').attr('id', 'barb'+d);
    	
    	var flags = Math.floor(d/50);
        var pennants = Math.floor((d - flags*50)/10);
        var halfpennants = Math.floor((d - flags*50 - pennants*10)/5);
        var px = barbsize;
        	    
		// Draw wind barb stems
		if (d == 0) {
			thisbarb.append("circle").attr("r", 2);
		} else {
			thisbarb.append("line").attr("class", "stem").attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", barbsize);
		}

     
    	// Draw wind barb flags and pennants for each stem
	    for (i=0; i<flags; i++) {
     		thisbarb.append("polyline")
                .attr("points", "0,"+px+" -10,"+(px)+" 0,"+(px-4))
     		    .attr("class", "flag");
     		 px -= 7;
     	}
	    // Draw pennants on each barb
	    for (i=0; i<pennants; i++) {
    	    thisbarb.append("line")
     		    .attr("x1", 0)
     		    .attr("x2", -10)
     		    .attr("y1", px)
     		    .attr("y2", px+4)
     		 px -= 3;
     	}
     	// Draw half-pennants on each barb
        for (i=0; i<halfpennants; i++) {
    	    thisbarb.append("line")
     		    .attr("x1", 0)
     		    .attr("x2", -5)
     		    .attr("y1", px)
     		    .attr("y2", px+2)
     		px -= 3;
     	}
	});
	
	var arrows = barbdef.append("marker")
		.attr("id","arrowhead")
		.attr("markerWidth","5")
		.attr("markerHeight","5")
		.attr("refX","5")
		.attr("refY","2.5")
		.attr("orient","auto")
		.append("polygon")
		.attr("points","0 0, 5 2.5, 0 5")
		.attr("fill","#777");
}

function drawSkew() {
	$(".member, .hododot, .hodoline, .titleText, .windbarb > *, .label").remove();
    for (var i=0; i<tlinetest[0][0].length; i+=1) {
        var tw = calcWetbulb(tlinetest[0][0][i].press, tlinetest[0][0][i].temp, tlinetest[0][0][i].dwpt);
	 	tlinetest[0][0][i].twc = tw;
        var svp = calcVaporPressure(tlinetest[0][0][i].temp);
	 	tlinetest[0][0][i].es = svp;
        var vp = calcVaporPressure(tlinetest[0][0][i].dwpt);
	 	tlinetest[0][0][i].e = vp;
        var mixr = calcMixingRatio(tlinetest[0][0][i].e, tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].mr = mixr;
	 	rh=calcRelHumidity(tlinetest[0][0][i].e, tlinetest[0][0][i].es);
	 	tlinetest[0][0][i].relh = rh;
		tv=getTv(tlinetest[0][0][i].temp,tlinetest[0][0][i].dwpt,tlinetest[0][0][i].press);
		 tlinetest[0][0][i].tv = tv;
	 	sh=calcSpecHumidity(tlinetest[0][0][i].e, tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].sh = sh;
	 	pT=calcTheta(tlinetest[0][0][i].press, tlinetest[0][0][i].temp);
	 	tlinetest[0][0][i].theta = pT;
	 	epT=calcThetaE(tlinetest[0][0][i].press, tlinetest[0][0][i].temp, tlinetest[0][0][i].dwpt );
	 	tlinetest[0][0][i].thetaE = epT;
	 	z = calcZ(tlinetest[0][0][i].press);
	 	tlinetest[0][0][i].Z = z;
    }

	var pw_total = calcPrecipWater();
	tlinetest[0][0][0].pw = pw_total;

	wb0_pres = calcFreezeLevel(true);
	tlinetest[0][0][0].wbz = wb0_pres;

	frz_lvl=calcFreezeLevel(false);
	tlinetest[0][0][0].frzl = frz_lvl;

	wbMelt_pres = calcMeltLevel(true);
	tlinetest[0][0][0].wbmelt = wbMelt_pres;

	melt_lvl=calcMeltLevel(false);
	tlinetest[0][0][0].meltl = melt_lvl;

	thk = calcThick();
	tlinetest[0][0][0].thick = thk;

	for (i=0; i<tlinetest[0][0].length-1; i++) {
		if (tlinetest[0][0][i].press == 1000) {
			t1000 = tlinetest[0][0][i].temp;
			td1000 = tlinetest[0][0][i].dwpt;
			ws1000 = tlinetest[0][0][i].wspd;
			wd1000 = tlinetest[0][0][i].wdir;
			flag_1000 = 1;
		} else if (tlinetest[0][0][i].press < 1000 && flag_1000 == 0) {
			if (i == 0) {
				t1000 = tlinetest[0][0][i].temp;
				td1000 = tlinetest[0][0][i].dwpt;
				ws1000 = tlinetest[0][0][i].wspd;
				wd1000 = tlinetest[0][0][i].wdir;
				flag_1000 = 1;
			} else {
				t1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
				td1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
				ws1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
				wd1000 = interpVal(1000, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
				flag_1000 = 1;
			}
		} else if (tlinetest[0][0][i].press == 850) {
			t850 = tlinetest[0][0][i].temp;
			td850 = tlinetest[0][0][i].dwpt;
			ws850 = tlinetest[0][0][i].wspd;
			wd850 = tlinetest[0][0][i].wdir;
			flag_850 = 1;
		} else if (tlinetest[0][0][i].press < 850 && flag_850 == 0) {
			t850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			td850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
			ws850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
			wd850 = interpVal(850, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
			flag_850 = 1;
		} else if (tlinetest[0][0][i].press == 700) {
			t700 = tlinetest[0][0][i].temp;
			td700 = tlinetest[0][0][i].dwpt;
			flag_700 = 1;
		} else if (tlinetest[0][0][i].press < 700 && flag_700 == 0) {
			t700 = interpVal(700, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			td700 = interpVal(700, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].dwpt, tlinetest[0][0][i-1].dwpt);
			flag_700 = 1;

		} else if (tlinetest[0][0][i].press == 500) {
			t500 = tlinetest[0][0][i].temp;
			ws500 = tlinetest[0][0][i].wspd;
			wd500 = tlinetest[0][0][i].wdir;
			flag_500 = 1;
		} else if (tlinetest[0][0][i].press < 500 && flag_500 == 0) {
			t500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].temp, tlinetest[0][0][i-1].temp);
			ws500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wspd, tlinetest[0][0][i-1].wspd);
			wd500 = interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, tlinetest[0][0][i].wdir, tlinetest[0][0][i-1].wdir);
			flag_500 = 1;
		} else {
		}
	}

	mixed_parcel = getParcelVals();
	p_pcl100 = mixed_parcel[0];
	t_pcl100 = mixed_parcel[1];
	td_pcl100 = mixed_parcel[2];
	tlinetest[0][0][0].mixParcelP = p_pcl100;
	tlinetest[0][0][0].mixParcelT = t_pcl100;
	tlinetest[0][0][0].mixParcelTd = td_pcl100;

	Tvmixed_parcel = getParcelVals("Tv");
	p_pcl100_tv = Tvmixed_parcel[0];
	t_pcl100_tv = Tvmixed_parcel[1];
	td_pcl100_tv = Tvmixed_parcel[2];
	tlinetest[0][0][0].mixParcelP_tv = p_pcl100_tv;
	tlinetest[0][0][0].mixParcelT_tv = t_pcl100_tv;
	tlinetest[0][0][0].mixParcelTd_tv = td_pcl100_tv;

	var pCCL = calcCCL();
	tlinetest[0][0][0].CCL = pCCL;

	var conv_temp = calcConvTemp();
	tlinetest[0][0][0].tc = conv_temp;

	tt=calcTT();//total totals
	tlinetest[0][0][0].TT = tt;

	ki=calcKI();//K-index
	tlinetest[0][0][0].KI = ki;

	sweat=calcSWEAT();
	tlinetest[0][0][0].SWEAT = sweat;

    lclData = calcLCL(tlinetest[0][0][0].press,tlinetest[0][0][0].temp,tlinetest[0][0][0].dwpt);
        plcl = lclData[0];
        tlcl = lclData[1];
        zlcl = lclData[2];
	tlinetest[0][0][0].lclP = plcl;
	tlinetest[0][0][0].lclT = tlcl;
	tlinetest[0][0][0].lclZ = zlcl;

	capeBounds = findLFCandEL("SB");
	plfc = capeBounds[0];
	tlfc = capeBounds[1];
	zlfc = capeBounds[2];
	pel = capeBounds[3];
	tel = capeBounds[4];
	zel = capeBounds[5];
	tlinetest[0][0][0].lfcP = plfc;
	tlinetest[0][0][0].lfcT = tlfc;
	tlinetest[0][0][0].lfcZ = zlfc;
	tlinetest[0][0][0].elP = pel;
	tlinetest[0][0][0].elT = tel;
	tlinetest[0][0][0].elZ = zel;

    mixlclData = calcLCL(tlinetest[0][0][0].mixParcelP,tlinetest[0][0][0].mixParcelT,tlinetest[0][0][0].mixParcelTd);
        mixplcl = mixlclData[0];
        mixtlcl = mixlclData[1];
        mixzlcl = mixlclData[2];
	tlinetest[0][0][0].lclPmix = mixplcl;
	tlinetest[0][0][0].lclTmix = mixtlcl;
	tlinetest[0][0][0].lclZmix = mixzlcl;

	mixcapeBounds = findLFCandEL("ML");
	mixplfc = mixcapeBounds[0];
	mixtlfc = mixcapeBounds[1];
	mixzlfc = mixcapeBounds[2];
	mixpel = mixcapeBounds[3];
	mixtel = mixcapeBounds[4];
	mixzel = mixcapeBounds[5];
	tlinetest[0][0][0].lfcPmix = mixplfc;
	tlinetest[0][0][0].lfcTmix = mixtlfc;
	tlinetest[0][0][0].lfcZmix = mixzlfc;
	tlinetest[0][0][0].elPmix = mixpel;
	tlinetest[0][0][0].elTmix = mixtel;
	tlinetest[0][0][0].elZmix = mixzel;

	TvlclData = calcLCL(tlinetest[0][0][0].press,tlinetest[0][0][0].tv,tlinetest[0][0][0].dwpt);
		plcl_tv = lclData[0];
		tlcl_tv = calcTC(plcl_tv,calcTheta(tlinetest[0][0][0].press, tlinetest[0][0][0].tv));
		zlcl_tv = lclData[2];
	tlinetest[0][0][0].lclP_tv = plcl_tv;
	tlinetest[0][0][0].lclT_tv = tlcl_tv;
	tlinetest[0][0][0].lclZ_tv = zlcl_tv;

	capeBounds_tv = findLFCandEL("SBTv");
	plfc_tv = capeBounds_tv[0];
	tlfc_tv = capeBounds_tv[1];
	zlfc_tv = capeBounds_tv[2];
	pel_tv = capeBounds_tv[3];
	tel_tv = capeBounds_tv[4];
	zel_tv = capeBounds_tv[5];
	tlinetest[0][0][0].lfcP_tv = plfc_tv;
	tlinetest[0][0][0].lfcT_tv = tlfc_tv;
	tlinetest[0][0][0].lfcZ_tv = zlfc_tv;
	tlinetest[0][0][0].elP_tv = pel_tv;
	tlinetest[0][0][0].elT_tv = tel_tv;
	tlinetest[0][0][0].elZ_tv = zel_tv;

	TvmixlclData = calcLCL(tlinetest[0][0][0].mixParcelP_tv,tlinetest[0][0][0].mixParcelT_tv,tlinetest[0][0][0].mixParcelTd);
		mixplcl_tv = mixlclData[0];
		mixtlcl_tv = calcTC(mixplcl_tv,calcTheta(tlinetest[0][0][0].press, tlinetest[0][0][0].mixParcelT_tv));
		mixzlcl_tv = mixlclData[2];
	tlinetest[0][0][0].lclPmix_tv = mixplcl_tv;
	tlinetest[0][0][0].lclTmix_tv = mixtlcl_tv;
	tlinetest[0][0][0].lclZmix_tv = mixzlcl_tv;

	mixcapeBounds_tv = findLFCandEL("MLTv");
	mixplfc_tv = mixcapeBounds_tv[0];
	mixtlfc_tv = mixcapeBounds_tv[1];
	mixzlfc_tv = mixcapeBounds_tv[2];
	mixpel_tv = mixcapeBounds_tv[3];
	mixtel_tv = mixcapeBounds_tv[4];
	mixzel_tv = mixcapeBounds_tv[5];
	tlinetest[0][0][0].lfcPmix_tv = mixplfc_tv;
	tlinetest[0][0][0].lfcTmix_tv = mixtlfc_tv;
	tlinetest[0][0][0].lfcZmix_tv = mixzlfc_tv;
	tlinetest[0][0][0].elPmix_tv = mixpel_tv;
	tlinetest[0][0][0].elTmix_tv = mixtel_tv;
	tlinetest[0][0][0].elZmix_tv = mixzel_tv;

	capeArray = getCAPE("SB", 0);//SBCAPE
	cape = capeArray[0];
	pcl_t_arr = capeArray[1];
	cin = capeArray[2];
	brn = capeArray[3][0];
	brnu = capeArray[3][1];
	shr6km = capeArray[4];
	tlinetest[0][0][0].cape = cape;
	tlinetest[0][0][0].cin = cin;
	tlinetest[0][0][0].brn = brn;
	tlinetest[0][0][0].brnu = brnu;
	tlinetest[0][0][0].shr6km = shr6km;

	if (pcl_t_arr[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (pcl_t_arr[i] != null) {
				tlinetest[0][0][i].parcelT = pcl_t_arr[i];
			}
		}
	}

	TvcapeArray = getCAPE("SB", 1);//SBCAPE
	cape_tv = TvcapeArray[0];
	pcl_t_arr_tv = TvcapeArray[1];
	cin_tv = TvcapeArray[2];
	brn_tv = TvcapeArray[3][0];
	brnu_tv = TvcapeArray[3][1];
	shr6km_tv = TvcapeArray[3][2];
	tlinetest[0][0][0].cape_tv = cape_tv;
	tlinetest[0][0][0].cin_tv = cin_tv;
	tlinetest[0][0][0].brn_tv = brn_tv;
	tlinetest[0][0][0].brnu_tv = brnu_tv;

	if (pcl_t_arr_tv[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (pcl_t_arr_tv[i] != null) {
				tlinetest[0][0][i].parcelT_tv = pcl_t_arr_tv[i];
			}
		}
	}

	mlcapeArray = getCAPE("ML", 0);//MLCAPE
	mlcape = mlcapeArray[0];
	ml_pcl_t_arr = mlcapeArray[1];
	mlcin = mlcapeArray[2];

	tlinetest[0][0][0].mlcape = mlcape;
	tlinetest[0][0][0].mlcin = mlcin;

	if (ml_pcl_t_arr[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (ml_pcl_t_arr[i] != null) {
				tlinetest[0][0][i].parcelTmix = ml_pcl_t_arr[i];
			}
		}
	}

	TvmlcapeArray = getCAPE("ML", 1);//MLCAPE
	mlcape_tv = TvmlcapeArray[0];
	ml_pcl_t_arr_tv = TvmlcapeArray[1];
	mlcin_tv = TvmlcapeArray[2];

	tlinetest[0][0][0].mlcape_tv = mlcape_tv;
	tlinetest[0][0][0].mlcin_tv = mlcin_tv;

	if (ml_pcl_t_arr_tv[0] === undefined) {
		parcel_flag = 0;
	} else {
		parcel_flag = 1;
		for (i=0; i<tlinetest[0][0].length; i++) {
			if (ml_pcl_t_arr_tv[i] != null) {
				tlinetest[0][0][i].parcelTmix_tv = ml_pcl_t_arr_tv[i];
			}
		}
	}

	var obs_t_arr = new Array();
	var pcl_t_arr = new Array();
	var obs_hght_arr = new Array();
	var ml_pcl_t_arr = new Array();
	for (i=0; i<tlinetest[0][0].length-1; i++) {
		obs_t_arr.push(tlinetest[0][0][i].temp);
		obs_hght_arr.push(tlinetest[0][0][i].hghtagl);
		pcl_t_arr.push(tlinetest[0][0][i].parcelT);
		ml_pcl_t_arr.push(tlinetest[0][0][i].parcelTmix);
	}

	li = calcLI(pcl_t_arr, obs_t_arr);
	tlinetest[0][0][0].LI  = li;

	limix = calcLI(ml_pcl_t_arr, obs_t_arr);
	tlinetest[0][0][0].LImix  = limix;

	tlinetest[0][0][0].LR_1km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 1000);
	tlinetest[0][0][0].LR_2km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 2000);
	tlinetest[0][0][0].LR_3km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 3000);
	tlinetest[0][0][0].LR_5km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 5000);
	tlinetest[0][0][0].LR_7km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 7000);
	tlinetest[0][0][0].LR_9km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 9000);
	tlinetest[0][0][0].LR_10km = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, 10000);
	tlinetest[0][0][0].LR_EL = getLapseRate(obs_t_arr, obs_hght_arr, 0, 0, tlinetest[0][0][0].elZ);

	for (i=0; i< tlinetest[0][0].length; i++) {
		if (tlinetest[0][0][0].lfcP > tlinetest[0][0][i].press) {
			var lfc_index = i
			break;
		}
	}
	tlinetest[0][0][0].LR_lfc_1km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 1000);
	tlinetest[0][0][0].LR_lfc_2km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 2000);
	tlinetest[0][0][0].LR_lfc_3km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 3000);
	tlinetest[0][0][0].LR_lfc_5km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 5000);
	tlinetest[0][0][0].LR_lfc_7km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 7000);
	tlinetest[0][0][0].LR_lfc_9km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 9000);
	tlinetest[0][0][0].LR_lfc_10km = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, 10000);
	tlinetest[0][0][0].LR_lfc_el = getLapseRate(obs_t_arr, obs_hght_arr, lfc_index, tlinetest[0][0][0].lfcZ, tlinetest[0][0][0].elZ-tlinetest[0][0][0].lfcZ);

	var bourgMod = getBourg("mod");
	tlinetest[0][0][0].me = bourgMod[0];
	tlinetest[0][0][0].re = bourgMod[1];

    // draw initial set of lines
    tlines = membergroup.selectAll("tlines") // Temperature
        .data(tlinetest[0]).enter().insert("path",":first-child")
          .attr("class", function(d,i) { return "temp member" })
          .attr("clip-path", "url(#clipper)")
		  .attr("d", line);
          
    tdlines = membergroup.selectAll("tdlines") // Dewpoint Temperature
        .data(tlinetest[0]).enter().insert("path",":first-child")
          .attr("class", function(d,i) { return "dwpt member" })
          .attr("clip-path", "url(#clipper)")
          .attr("d", line2);

    var line3 = d3.svg.line() // Wet-bulb Temp
        .interpolate("linear")
        .x(function(d,i) { return x(d.twc) + (y(basep)-y(d.press))/tan; })
        .y(function(d,i) { return y(d.press); });

	if ($("#twc_check").prop("checked")) {
		twlines = membergroup.selectAll("twlines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "twc member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line3);
	}

    var line4 = d3.svg.line() // Virtual Temp
        .interpolate("linear")
        .x(function(d,i) { return x(d.tv) + (y(basep)-y(d.press))/tan; })
        .y(function(d,i) { return y(d.press); });

	if ($("#tvc_check").prop("checked")) {		
		tvlines = membergroup.selectAll("tvlines")
			.data(tlinetest[0]).enter().insert("path",":first-child")
			.attr("class", function(d,i) { return "tvc member" })
			.attr("clip-path", "url(#clipper)")
			.attr("d", line4);
	}

	if ($("input[name='CAPE_check']:checked").val() == "T") {
		var line5 = d3.svg.line() // Parcel Temp
			.interpolate("linear")
			.x(function(d,i) { return x(d.parcelT) + (y(basep)-y(d.press))/tan; })
			.y(function(d,i) { return y(d.press); });
					
		if ($("#parcel_check").prop("checked")) {
			parlines = membergroup.selectAll("parcellines")
				.data(tlinetest[0]).enter().insert("path",":first-child")
				.attr("class", function(d,i) { return "parcel member" })
				.attr("clip-path", "url(#clipper)")
				.attr("d", line5);
		}

		var line6 = d3.svg.line() // Mixed Parcel Temp
			.interpolate("linear")
			.x(function(d,i) { return x(d.parcelTmix) + (y(basep)-y(d.press))/tan; })
			.y(function(d,i) { return y(d.press); });
					
		if ($("#parcelmix_check").prop("checked")) {
			parlines = membergroup.selectAll("parcellines")
				.data(tlinetest[0]).enter().insert("path",":first-child")
				.attr("class", function(d,i) { return "parcelmix member" })
				.attr("clip-path", "url(#clipper)")
				.attr("d", line6);
		}
	} else {
		var line7 = d3.svg.line() // Parcel Temp (Tv)
			.interpolate("linear")
			.x(function(d,i) { return x(d.parcelT_tv) + (y(basep)-y(d.press))/tan; })
			.y(function(d,i) { return y(d.press); });
					
		if ($("#parcel_check").prop("checked")) {
			parlines = membergroup.selectAll("parcellines")
				.data(tlinetest[0]).enter().insert("path",":first-child")
				.attr("class", function(d,i) { return "parcel_tv member" })
				.attr("clip-path", "url(#clipper)")
				.attr("d", line7);
		}

		var line8 = d3.svg.line() // Mixed Parcel Temp (Tv)
			.interpolate("linear")
			.x(function(d,i) { return x(d.parcelTmix_tv) + (y(basep)-y(d.press))/tan; })
			.y(function(d,i) { return y(d.press); });
					
		if ($("#parcelmix_check").prop("checked")) {
			parlines = membergroup.selectAll("parcellines")
				.data(tlinetest[0]).enter().insert("path",":first-child")
				.attr("class", function(d,i) { return "parcelmix_tv member" })
				.attr("clip-path", "url(#clipper)")
				.attr("d", line8);
		}
	}

    holines = hodogroup.selectAll("hodolines")
        .data(hodobarbstest[0]).enter().append("path")
    	.attr("class", function(d,i) { return "hodoline member" })
		.attr("d", hodoline);
          
    hododots = hodogroup.selectAll('hododots')
    	.data(flattened.slice(0,55)).enter().append("circle")
    	.attr("r", function(d, i) { return (i<50) ? 4 : 8 })
    	.attr("cx", function(d, i) { return r(d.wspd * Math.sin((180+d.wdir)*d2r)); })
		.attr("cy", function(d, i) { return -r(d.wspd * Math.cos((180+d.wdir)*d2r)); })
//		.attr("class", function(d,i) { return "hododot hgt"+((d.hghtagl/1000)}); // On upload of or reload of a preset sounding, the hododots lost their color because hghtagl wasn't defined.
		.attr("class", function(d,i) { return "hododot hgt"+((d.hght - tlinetest[0][0][0].hght)/1000)}); 
	
	if (lat < 0) {
		barbdata = barbgroup.selectAll("barbs")
		.data(barbstest[0][0]).enter().append("g").attr("class","inactiveBarb")
		.attr("transform", function(d,i) { return "translate("+width+","+y(d.press)+") rotate("+(d.wdir-90)+") scale(1,-1)" });
	} else {
		barbdata = barbgroup.selectAll("barbs")
		.data(barbstest[0][0]).enter().append("g").attr("class","inactiveBarb")
		.attr("transform", function(d,i) { return "translate("+width+","+y(d.press)+") rotate("+(d.wdir-90)+")"; });
	}

    allbarbs = barbdata.append("use")
    	.attr("href", function (d) { return "#barb"+d.wspdround; })
		.attr("transform", function(d,i) { return "rotate(270)"; });

//    allbarbs = barbdata.append("use")
//    	.attr("href", function (d) { return "#speedRect"; });



}

function drawText() {
	$(".label").remove();
	d3.selectAll("text.titleText > *").remove();
	d3.selectAll("text.indexVal").remove();
	units = [' mb', ' mb', ' mb', ' mb', ' mb', ' mb', ' J/kg', ' J/kg', ' J/kg', ' J/kg', '', ' m2/s2', ' kts', '', '', '', '', '', ' mb', ' ˚C', ' m', ' mb', ' mb', ' in', " %", " g/kg", " hPa", " g/kg", " K", " K", " J/kg", " J/kg"];
	indices = [];
	if ($("input[name='CAPE_check']:checked").val() == "Tv") {
		indices.push(tlinetest[0][0][0].elP_tv);
		indices.push(tlinetest[0][0][0].elPmix_tv);
		indices.push(tlinetest[0][0][0].lfcP_tv);
		indices.push(tlinetest[0][0][0].lfcPmix_tv);
		indices.push(tlinetest[0][0][0].lclP_tv);
		indices.push(tlinetest[0][0][0].lclPmix_tv);
		indices.push(tlinetest[0][0][0].cape_tv);
		indices.push(tlinetest[0][0][0].mlcape_tv);
		indices.push(tlinetest[0][0][0].cin_tv);
		indices.push(tlinetest[0][0][0].mlcin_tv);
		indices.push(tlinetest[0][0][0].brn_tv);
	} else {
		indices.push(tlinetest[0][0][0].elP);
		indices.push(tlinetest[0][0][0].elPmix);
		indices.push(tlinetest[0][0][0].lfcP);
		indices.push(tlinetest[0][0][0].lfcPmix);
		indices.push(tlinetest[0][0][0].lclP);
		indices.push(tlinetest[0][0][0].lclPmix);
		indices.push(tlinetest[0][0][0].cape);
		indices.push(tlinetest[0][0][0].mlcape);
		indices.push(tlinetest[0][0][0].cin);
		indices.push(tlinetest[0][0][0].mlcin);
		indices.push(tlinetest[0][0][0].brn);
	}
	indices.push(tlinetest[0][0][0].brnu);
	indices.push(tlinetest[0][0][0].shr6km);
	indices.push(tlinetest[0][0][0].LI);
	indices.push(tlinetest[0][0][0].LImix);
	indices.push(tlinetest[0][0][0].KI);
	indices.push(tlinetest[0][0][0].TT);
	indices.push(tlinetest[0][0][0].SWEAT);

	indices.push(tlinetest[0][0][0].CCL);
	indices.push(tlinetest[0][0][0].tc);
	indices.push(tlinetest[0][0][0].thick);
	indices.push(tlinetest[0][0][0].wbz);
	indices.push(tlinetest[0][0][0].frzl);
	indices.push(tlinetest[0][0][0].pw);

	indices.push(tlinetest[0][0][0].relh);
	indices.push(tlinetest[0][0][0].mr.toPrecision(4));
	indices.push(tlinetest[0][0][0].e.toPrecision(4));
	indices.push(tlinetest[0][0][0].sh);
	indices.push(tlinetest[0][0][0].theta);
	indices.push(tlinetest[0][0][0].thetaE);
	indices.push(tlinetest[0][0][0].me);
	indices.push(tlinetest[0][0][0].re);

	d3.selection.prototype.eq = function (index) {
		return d3.select(this[0][index]);
	};
		
	$("#indices tbody tr").each(function(i) {
		$(this).find("td:eq(1)").text(indices[i] + " " + units[i]).attr('class', 'indexVal ' + labels[i].replace(/\s/g, '').replace(/\(/g, '').replace(/\)/g, ''));
	});
    
    if (tlinetest[0][0][0].wbz[0] > topp) {
		if ($("#twc_check").prop("checked")) {
			wb0 = labelgroup.selectAll("wbz")
			.data(tlinetest[0][0][0].wbz).enter().insert("rect",":first-child") 
				.attr('x', width-70)
				.attr('y', function(d) { return y(d) })
				.attr('width', 20)
				.attr('height', 2)
				.attr('class', 'wbz_rectline label');
		
			wb0text = labelgroup.selectAll("wbztext")
			.data(tlinetest[0][0][0].wbz).enter().insert("text",":first-child")
				.attr('x', width-72)
				.attr('y', function(d) { return y(d) })
				.attr('dy', '0.4em')
				.attr('text-anchor', 'end')
				.attr('class', 'wbztext label')
				.text(function(d) { return d + " mb"; });
		}
    }

    if (tlinetest[0][0][0].frzl[0] > topp) {
		frzl = labelgroup.selectAll("frzl")
		.data(tlinetest[0][0][0].frzl).enter().insert("rect",":first-child")
			.attr('x', width-70)
			.attr('y', function(d,i) { return y(d)})
			.attr('width', 20)
			.attr('height', 2)
			.attr('class', 'frzl_rectline label');
	
		frzltext = labelgroup.selectAll("frzltext")
		.data(tlinetest[0][0][0].frzl).enter().insert("text",":first-child")
			.attr('x', width-72)
			.attr('y', function(d,i) { return y(d)})
			.attr('dy', '0.4em')
			.attr('text-anchor', 'end')
			.attr('class', 'frzltext label')
			.text(function(d,i) { return d + " mb"; });
    }

    if (tlinetest[0][0][0].lclP > 100) {
		if ($("#parcel_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				lcl = labelgroup.selectAll("lcl")
				.data([tlinetest[0][0][0].lclP_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lcl rectline label');
					
				lcltext = labelgroup.selectAll("lcltext")
				.data([tlinetest[0][0][0].lclP_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lcltext label')
					.text(function(d,i) { return tlinetest[0][0][0].lclP_tv + " mb"; });
			} else {
				lcl = labelgroup.selectAll("lcl")
				.data([tlinetest[0][0][0].lclP]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lcl rectline label');
					
				lcltext = labelgroup.selectAll("lcltext")
				.data([tlinetest[0][0][0].lclP]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclP)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lcltext label')
					.text(function(d,i) { return tlinetest[0][0][0].lclP + " mb"; });
			}
		}
    }

    if (tlinetest[0][0][0].lclPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				lcl = labelgroup.selectAll("lcl")
				.data([tlinetest[0][0][0].lclPmix_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lclmix rectline label');
					
				lcltext = labelgroup.selectAll("lcltext")
				.data([tlinetest[0][0][0].lclPmix_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lclmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].lclPmix_tv + " mb (mix)"; });
			} else {
				lcl = labelgroup.selectAll("lcl")
				.data([tlinetest[0][0][0].lclPmix]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lclmix rectline label');
					
				lcltext = labelgroup.selectAll("lcltext")
				.data([tlinetest[0][0][0].lclPmix]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lclPmix)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lclmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].lclPmix + " mb (mix)"; });
			}
		}
    }

    if (tlinetest[0][0][0].lfcP > 100) {
		if ($("#parcel_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				lfc = labelgroup.selectAll("lfc")
				.data([tlinetest[0][0][0].lfcP_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lfc rectline label');
					
				lfctext = labelgroup.selectAll("lfctext")
				.data([tlinetest[0][0][0].lfcP_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lfctext label')
					.text(function(d,i) { return tlinetest[0][0][0].lfcP_tv + " mb"; });
			} else {
				lfc = labelgroup.selectAll("lfc")
				.data([tlinetest[0][0][0].lfcP]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lfc rectline label');
					
				lfctext = labelgroup.selectAll("lfctext")
				.data([tlinetest[0][0][0].lfcP]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcP)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lfctext label')
					.text(function(d,i) { return tlinetest[0][0][0].lfcP + " mb"; });				
			}
		}
    }

    if (tlinetest[0][0][0].elP > 100) {
		if ($("#parcel_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				el = labelgroup.selectAll("el")
				.data([tlinetest[0][0][0].elP_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'el rectline label');
					
				eltext = labelgroup.selectAll("eltext")
				.data([tlinetest[0][0][0].elP_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'eltext label')
					.text(function(d,i) { return tlinetest[0][0][0].elP_tv + " mb"; });
			} else {
				el = labelgroup.selectAll("el")
				.data([tlinetest[0][0][0].elP]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'el rectline label');
					
				eltext = labelgroup.selectAll("eltext")
				.data([tlinetest[0][0][0].elP]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elP)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'eltext label')
					.text(function(d,i) { return tlinetest[0][0][0].elP + " mb"; });
			}

		}
    }

    if (tlinetest[0][0][0].lfcPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				lfc = labelgroup.selectAll("lfcmix")
				.data([tlinetest[0][0][0].lfcPmix_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lfcmix rectline label');
					
				lfctext = labelgroup.selectAll("lfcmixtext")
				.data([tlinetest[0][0][0].lfcPmix_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lfcmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].lfcPmix_tv + " mb (mix)"; });
			} else {
				lfc = labelgroup.selectAll("lfcmix")
				.data([tlinetest[0][0][0].lfcPmix]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'lfcmix rectline label');
					
				lfctext = labelgroup.selectAll("lfcmixtext")
				.data([tlinetest[0][0][0].lfcPmix]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].lfcPmix)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'lfcmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].lfcPmix + " mb (mix)"; });
			}
		}
    }

    if (tlinetest[0][0][0].elPmix > 100) {
		if ($("#parcelmix_check").prop("checked")) {
			if ($("input[name='CAPE_check']:checked").val() == "Tv") {
				el = labelgroup.selectAll("elmix")
				.data([tlinetest[0][0][0].elPmix_tv]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix_tv)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'elmix rectline label');
					
				eltext = labelgroup.selectAll("elmixtext")
				.data([tlinetest[0][0][0].elPmix_tv]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix_tv)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'elmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].elPmix_tv + " mb (mix)"; });
			} else {
				el = labelgroup.selectAll("elmix")
				.data([tlinetest[0][0][0].elPmix]).enter().insert("rect",":first-child")
					.attr('x', width-70)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix)})
					.attr('width', 20)
					.attr('height', 2)
					.attr('class', 'elmix rectline label');
					
				eltext = labelgroup.selectAll("elmixtext")
				.data([tlinetest[0][0][0].elPmix]).enter().insert("text",":first-child")
					.attr('x', width-72)
					.attr('y', function(d,i) { return y(tlinetest[0][0][0].elPmix)})
					.attr('dy', '0.4em')
					.attr('text-anchor', 'end')
					.attr('class', 'elmixtext label')
					.text(function(d,i) { return tlinetest[0][0][0].elPmix + " mb (mix)"; });
			}
		}
    }

//    titleText = labelgroup.selectAll("title")
	titleText = d3.select("#mainbox svg g g.skewtbg").selectAll("title")
	  .data([title]).enter().insert("text",":first-child")
        .attr('dy', '0.4em')
    	.attr('class', 'titleText')
    	.attr('text-anchor', 'left')
		.attr("transform", "translate(0,-15)")
    	.text(title);
}

function drawToolTips() {
	$(".overlay").remove();
	focusgroup.insert("rect")
	  .attr("class", "overlay") 

	// Define drag beavior
	var drag = d3.behavior.drag()
		.on("dragstart", dragStart)
		.on("drag", dragMove)
		.on("dragend", dragEnd);

  // Draw T/Td tooltips
  focus3 = focusgroup.insert("g",":first-child").attr("class", "focus twc").style("display", "none");
  focus3.append("circle").attr("r", 4);
  focus3.append("text").attr("x", -9).attr("y",14).attr("text-anchor", "end").attr("dy", ".35em");

  focus4 = focusgroup.insert("g",":first-child").attr("class", "focus tvc").style("display", "none");
  focus4.append("circle").attr("r", 4);
  focus4.append("text").attr("x", 9).attr("y",-14).attr("dy", ".35em");

	if (parcel_flag=1) {
	  focus5 = focusgroup.insert("g",":first-child").attr("class", "focus parcel").style("display", "none");
	  focus5.append("circle").attr("r", 4);
	  focus5.append("text").attr("x", 9).attr("y", 14).attr("dy", ".35em");

	  focus5b = focusgroup.insert("g",":first-child").attr("class", "focus parcelmix").style("display", "none");
	  focus5b.append("circle").attr("r", 4);
	  focus5b.append("text").attr("x", 9).attr("y", -14).attr("dy", ".35em");
	}

  focus6 = focusgroup.insert("g",":first-child").attr("class", "focus alt").style("display", "none");
  focus6.append("text").attr("x", 0).attr("text-anchor", "start").attr("dy", ".35em");

  focus6b = focusgroup.insert("g",":first-child").attr("class", "focus pres").style("display", "none");
  focus6b.append("text").attr("x", 11).attr("y", -14).attr("text-anchor", "start").attr("dy", ".35em");

  focus6c = focusgroup.insert("g",":first-child").attr("class", "focus falt").style("display", "none");
  focus6c.append("text").attr("x", 11).attr("y", 14).attr("text-anchor", "start").attr("dy", ".35em");

  focus7 = focusgroup.append("g",":first-child").attr("class", "focus windt").style("display", "none").call(dragWind);
  focus7.append("circle").attr("r", 4);
  focus7.append("text").attr("x", -32).attr("text-anchor", "end").attr("dy", ".35em");

  focus2 = focusgroup.append("g").attr("class", "focus dwpc draggable").attr("id","dragDew").style("display", "none").call(drag);
  focus2.append("circle").attr("r", 6);
  focus2.append("text").attr("x", -9).attr("text-anchor", "end").attr("dy", ".35em");
  
  focus = focusgroup.append("g").attr("class", "focus tmpc draggable").attr("id","dragTemp").style("display", "none").call(drag);
  focus.append("circle").attr("r", 6);
  focus.append("text").attr("x", 9).attr("dy", ".35em");

  d3.selectAll(".overlay, .skewt")
  	.attr("width", width)
	.attr("height", height);

  plotChecks();
}

d3.selectAll(".skewt, .windbarb")
.on("mouseover", function() { $(".focus").show();})
.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb");});

d3.selectAll(".skewt, .windbarb")
	.on("mousemove", mousemove);

var ind = "";
var idx;
var mouseTemp = "";

function mousemove() {
	idx = "";
	var y0 = y.invert(d3.mouse(this)[1]); // get y value of mouse pointer in pressure space
	var i = bisectTemp(mouseoverdata, y0, 1, mouseoverdata.length-1);
	var d0 = mouseoverdata[i - 1];
	var d1 = mouseoverdata[i];
	var d = y0 - d0.press > d1.press - y0 ? d1 : d0;

	focus.attr("transform", "translate(" + (x(d.temp) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus2.attr("transform", "translate(" + (x(d.dwpt) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus3.attr("transform", "translate(" + (x(d.twc) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	focus4.attr("transform", "translate(" + (x(d.tv) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	if ($("input[name='CAPE_check']:checked").val() == "Tv") {
		focus5.attr("transform", "translate(" + (x(d.parcelT_tv) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
		focus5b.attr("transform", "translate(" + (x(d.parcelTmix_tv) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	} else {
		focus5.attr("transform", "translate(" + (x(d.parcelT) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
		focus5b.attr("transform", "translate(" + (x(d.parcelTmix) + (y(basep)-y(d.press))/tan)+ "," + y(d.press) + ")");
	}

	focus6.attr("transform", "translate(0," + y(d.press) + ")");
	focus6b.attr("transform", "translate(0," + y(d.press) + ")");
	focus6c.attr("transform", "translate(0," + y(d.press) + ")");
	focus7.attr("transform", "translate(" + width + "," + y(d.press) + ")");

	var currPress = $(".pres").find("text").text().trim().split("m");
	currPress = currPress[0];

	for (k=0; k < tlinetest[0][0].length; k++) {
		var elem = tlinetest[0][0][k].press;
		if (elem == currPress) {
			idx = k;
			break;
		}
	};

	d3.select(".hodogroup circle")
		.attr("cx", function () {return r(d.wspd * Math.sin((180+d.wdir)*d2r))})
		.attr("cy", function () {return -r(d.wspd * Math.cos((180+d.wdir)*d2r))});
	d3.select(".hodogroup line")
		.attr("x2", function () {return r(d.wspd * Math.sin((180+d.wdir)*d2r))})
		.attr("y2", function () {return -r(d.wspd * Math.cos((180+d.wdir)*d2r))});

	$(".windbarb g").attr("class", "inactiveBarb");
	$(".windbarb g:eq(" + idx + ")").attr("class", "activeBarb");
	d3.selectAll(".activeBarb").call(dragWind)

	focus.select("text").text(Math.round(d.temp)+"°C");
	focus2.select("text").text(Math.round(d.dwpt)+"°C");
	focus3.select("text").text(Math.round(d.twc)+"°C");
	focus4.select("text").text(Math.round(d.tv)+"°C");
	if ($("input[name='CAPE_check']:checked").val() == "Tv") {
		focus5.select("text").text(Math.round(d.parcelT_tv)+"°C (SB)");
		focus5b.select("text").text(Math.round(d.parcelTmix_tv)+"°C (mix)");
	} else {
		focus5.select("text").text(Math.round(d.parcelT)+"°C (SB)");
		focus5b.select("text").text(Math.round(d.parcelTmix)+"°C (mix)");
	}
	focus6.select("text").text("<-"+(Math.round(d.hghtagl/100)/10)+"km");
	focus6b.select("text").text("  " + d.press+"mb");
	focus6c.select("text").text("  " + Math.round(d.hghtagl*3.28) + "ft");
	focus7.select("text").text(d.wspd+` @`+d.wdir+"˚");
	$(".RH").text(d.relh + "%")
	var mrText = d.mr.toFixed(2) + "\u00A0g/kg";
	$(".MixingRatio").text(mrText)
	var eText = d.e.toFixed(2) + "\u00A0hPa";
	$(".VaporPressure").text(eText);
	$(".SpecHum").text(d.sh + "\u00A0g/kg")
	$(".Theta").text(d.theta + "\u00A0K")
	$(".ThetaE").text(d.thetaE + "\u00A0K")

}

var dragWind = d3.behavior.drag()
    .on("dragstart", dragWindStart)
    .on("drag", dragWindMoveCircular)
    .on("dragend", dragWindEnd);

var dragLocX;
var currWind, currWindSpeed;
var ringSize, origRingSize;
var origTransform, origTranslate, origTranslateX, origTranslateY, origRotate, origHypotenuse;
var ringZero = 30;

function dragWindStart () {
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.falt, .focus.tmpc, .focus.dwpc, .focus.hod, .focus.hodarrow").css("display", "none");
	currWindSpeed = tlinetest[0][0][idx].wspd;

	var X = $('body').offset().left;
	var Y = $('body').offset().top;
	mouseX = event.pageX - X;
	mouseY = event.pageY - Y;

	var rPos = rPosition(mouseX, mouseY);
	origHypotenuse = Math.sqrt(rPos[0]**2 + rPos[1]**2).toFixed(0);

    ringSize = currWindSpeed+ringZero;
    origRingSize = currWindSpeed+ringZero;
    d3.selectAll(".activeBarb").append("g").attr("id","speedRing")
        .append("circle").attr("id","speedCircle").attr("r",ringSize).attr("fill","none").attr("stroke-width","2px");
    d3.selectAll(".activeBarb").select("g#speedRing").append("circle").attr("id","speedDot").attr("r","4px").attr("transform", "translate("  + ringSize + ",0)");
	dragLocX = d3.mouse(this);
    dragLocX = dragLocX[0];
	origTransform = $(".activeBarb").attr("transform");
	origTransform = origTransform.split(")");
    origTranslate = origTransform[0];
    origRotate = origTransform[1];
    origRotate = origRotate.split("(");
    origRotate = origRotate[1];
	origTranslate = origTranslate.split(",");
	origTranslateX = origTranslate[0].split("(");
	origTranslateX = parseFloat(origTranslateX[1]);
	origTranslateY = parseFloat(origTranslate[1]);

	event.preventDefault();
	var undoObj = {
		"index": idx,
		"press": tlinetest[0][0][idx].press,
		"temp": tlinetest[0][0][idx].temp,
		"dwpt": tlinetest[0][0][idx].dwpt,
		"wdir": tlinetest[0][0][idx].wdir,
		"wspd": tlinetest[0][0][idx].wspd,
		"wspdround": tlinetest[0][0][idx].wspdround
	}
	undoArr.unshift(undoObj);
	$("#undo").prop("disabled", false);
}
		
var coords;
var prevCoords = 0;

function rPosition(mouseX, mouseY) {
  var offset = $('.windt circle').offset();
  var x = mouseX - offset.left;
  var y = mouseY - offset.top;
  return [x, y];
}

function dragWindMoveCircular () {
    event.preventDefault();
	d3.selectAll(".skewt, .windbarb")
		.on("mousemove", null)
		.on("mouseover", null)
		.on("mouseout", null);

	var transform = $(this).attr("transform");
	transform = transform.split(")");
	translate = transform[0]
	translate = translate.split(",")
	translateX = translate[0].split("(");
	translateX = parseFloat(translateX[1]);
	translateY = parseFloat(translate[1]);

	var X = $('body').offset().left;
	var Y = $('body').offset().top;
	mouseX = event.pageX - X;
	mouseY = event.pageY - Y;

	var rPos = rPosition(mouseX, mouseY);
	var hypotenuse = Math.sqrt(rPos[0]**2 + rPos[1]**2).toFixed(0);
	var hypoDiff = parseFloat(hypotenuse) - parseFloat(origHypotenuse);
	ringSize =  parseFloat(hypotenuse);
	var angle = Math.atan(rPos[0]/rPos[1])*180/Math.PI;

	if (rPos[0] >= 0 && rPos[1] < 0) { // +x, -y (upper-right quadrant)
		newRotate = -angle-90;
	} else if (rPos[0] < 0 && rPos[1] < 0) { // -x, -y (upper-left quadrant) 
		newRotate = -angle-90;
	} else if (rPos[0] < 0 && rPos[1] >= 0) { // -x, +y (lower-left quadrant)
		newRotate = -angle+90;
	} else { // +x, +y (lower-right quadrant)
		newRotate = -angle-270;
	}

	var windDir = newRotate+90;

	if (windDir > 360) {
		windDir = windDir - 360;
	}
	if (windDir < 0) {
		windDir = windDir + 360;
	}

	newWspd = ringSize - ringZero;
	if (newWspd <= 0) {
		newWspd = 0;
		ringSize = ringZero;
	} else if (newWspd >= 200) {
		newWspd = 200;
		ringSize = ringZero + 200;
	}

	windDir = windDir.toFixed(0);
	tlinetest[0][0][idx].wdir = parseFloat(windDir);
	if (idx < hodobarbstest[0][0].length) {
		hodobarbstest[0][0][idx].wdir = parseFloat(windDir);
        hodobarbstest[0][0][idx].wspd = parseFloat(newWspd);
        hodobarbstest[0][0][idx].wspdround = Math.round(newWspd/5)*5;
	}
	interpDots(hodobarbstest);

	$(".windt").children().text("" + newWspd + " @" + windDir+ "˚");
	d3.selectAll(".activeBarb").attr("transform","translate(" + translateX + ", " + translateY + ") rotate(" + newRotate + ")");
	drawSkew();
    $(".windbarb g:eq(" + idx + ")").attr("class", "activeBarb");
    d3.selectAll(".windbarb").append("g")
        .attr("id","origSpeedRing")
        .attr("transform","translate(" + origTranslateX + ", " + origTranslateY + ") rotate(" + origRotate + ")")
        .append("circle")
        .attr("id","origSpeedCircle")
        .attr("r",origRingSize)
        .attr("fill","none")
        .attr("stroke-width","2px")
        .attr("stroke","gray")
        .attr("stroke-dasharray", "4");
    d3.selectAll("#origSpeedRing").append("circle")
        .attr("id","origSpeedDot")
        .attr("r","4px")
        .attr("transform", "translate("  + origRingSize + ",0)")
        .attr("fill","gray");

    d3.selectAll(".activeBarb").append("g").attr("id","speedRing")
        .append("circle").attr("id","speedCircle").attr("r",ringSize).attr("fill","none").attr("stroke-width","2px");
    d3.selectAll(".activeBarb").select("g#speedRing").append("circle").attr("id","speedDot").attr("r","4px").attr("transform", "translate("  + ringSize + ",0)");
	drawText();
	tabulate("editTable", columns, tlinetest[0][0],true);
}
			
function dragWindEnd () {
	d3.selectAll(".skewt, .windbarb")
		.on("mouseover", function() { $(".focus").show()})
		.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb")})
		.on("mousemove", mousemove);
    $("#speedRing, #origSpeedRing").remove();
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.falt, .focus.tmpc, .focus.dwpc").css("display", "");
}

var yTrans = 0;

function dragStart(d) {
	event.preventDefault();
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.falt, .focus.windt").css("display", "none");
	yTrans = d3.select(this).attr("transform");
  	yTrans = yTrans.split(",");
  	yTrans = yTrans[1].split(")");
	yTrans = yTrans[0];
	var undoObj = {
		"index": idx,
		"press": tlinetest[0][0][idx].press,
		"temp": tlinetest[0][0][idx].temp,
		"dwpt": tlinetest[0][0][idx].dwpt,
		"wdir": tlinetest[0][0][idx].wdir,
		"wspd": tlinetest[0][0][idx].wspd,
		"wspdround": tlinetest[0][0][idx].wspdround
	}
	undoArr.unshift(undoObj);
	$("#undo").prop("disabled", false);
}

function dragMove(d) {
	var xLoc = d3.event.x;
	$(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.falt, .focus.windt, .focus.hod, .focus.hodarrow").css("display", "none");

  d3.selectAll(".skewt, .windbarb")
  	.on("mousemove", null)
	.on("mouseover", null)
	.on("mouseout", null);

  var pres = [];
  for (k=0; k < tlinetest[0][0].length; k++) {
	var elem = tlinetest[0][0][k].press;
	pres.push(elem);
  };

  var currPress = $(".pres").find("text").text().trim().split("m");
  currPress = currPress[0];
  ind = pres.indexOf(parseFloat(currPress));
  if (xLoc >= 0 && xLoc < 625) {
	  d3.select(this).attr("transform", "translate(" + xLoc + "," + yTrans + ")");
  } else {
		return;
  }

  var elId = $(this).attr("id");

  if (elId == "dragDew") {
		var otherXLoc = $("#dragTemp").attr("transform");
		otherXLoc = otherXLoc.split(",");
		otherXLoc = otherXLoc[0].split("(");
		otherXLoc = otherXLoc[1];
		
		if (xLoc >= 0 && xLoc < 625) {
			mouseTemp = x.invert(xLoc - (y(basep)-yTrans)/tan);
			// Redraw label (truncated value)
			$(this).find('text').text(Math.round(mouseTemp) + "˚C");
			// Modify that element in line2[el] or tlinetest[0][0][el].dwpt
			tlinetest[0][0][ind].dwpt = parseFloat(mouseTemp.toFixed(2));
			if (otherXLoc <= xLoc) {
				tlinetest[0][0][ind].temp = parseFloat(mouseTemp.toFixed(2));
				d3.select("#dragTemp").attr("transform", "translate(" + xLoc + "," + yTrans + ")");
				$("#dragTemp").find("text").text(Math.round(mouseTemp) + "˚C");
			}
		}

  } else if (elId == "dragTemp") {
	var otherXLoc = $("#dragDew").attr("transform");
		otherXLoc = otherXLoc.split(",");
		otherXLoc = otherXLoc[0].split("(");
		otherXLoc = otherXLoc[1];

		if (xLoc >= 0 && xLoc < 625) {
			mouseTemp = x.invert(xLoc - (y(basep)-yTrans)/tan);
			// Redraw label (truncated value)
			$(this).find('text').text(Math.round(mouseTemp) + "˚C");
			// Modify the element in line[el] or tlinetest[0][0][el].temp
			tlinetest[0][0][ind].temp = parseFloat(mouseTemp.toFixed(2));
			if (otherXLoc >= xLoc) {
				tlinetest[0][0][ind].dwpt = parseFloat(mouseTemp.toFixed(2));
				d3.select("#dragDew").attr("transform", "translate(" + xLoc + "," + yTrans + ")");
				$("#dragDew").find("text").text(Math.round(mouseTemp) + "˚C");
			}
		}

		
  } else {
	  	console.log("Didn't find that ID for dragging");
  }
  drawSkew();
  drawText();
  tabulate("editTable", columns, tlinetest[0][0],true);

  if (xLoc <= 0) {
	  dragEnd();
  } else if (xLoc > 625) {
	  dragEnd();
  }

}

function dragEnd(d) {
  d3.selectAll(".skewt, .windbarb").on("mousemove", mousemove);
  $(".focus.twc, .focus.tvc, .focus.parcel, .focus.parcelmix, .focus.alt, .focus.pres, .focus.falt, .focus.windt, .focus.hod, .focus.hodarrow").css("display", "");

  d3.selectAll(".skewt, .windbarb")
  	.on("mouseover", function() { $(".focus").show();})
  	.on("mouseout", function() { $(".focus").hide(); $(".activeBarb").attr("class", "inactiveBarb");});

}

function drawTextLabels() {

spacing = 20;
var headers = ['','',];
/*labels = ['EL', 'EL (mixed)', 'LFC', 'LFC (mixed)', 'LCL', 'LCL (mixed)', 'SBCAPE', 'MLCAPE', 'CIN', 'MLCIN', 'BRN', 'BRN Shear', 'Shear 6km', 'LI', 'LI (mixed)', 'KI', 'TT', 'SWEAT'];
labels2 = ['CCL', 'Tc', 'Thickness', 'Wet-Bulb 0˚', 'Freezing Lvl', 'PW', 'RH', 'Mixing Ratio', 'Vapor Pres', 'Spec Hum', 'Theta', 'ThetaE']; GP:MOD*/
labels = ['EL', 'EL (mixed)', 'LFC', 'LFC (mixed)', 'LCL', 'LCL (mixed)', 'SBCAPE', 'MLCAPE', 'CIN', 'MLCIN', 'Bulk Richardson Num.', 'Bulk Richardson Num. Shear', 'Shear 6km', 'Lifted Index', 'Lifted Index (mixed)', 'K Index', 'Total Totals', 'SWEAT', 'CCL', 'Tc', 'Thickness', 'Wet-Bulb 0˚', 'Freezing Lvl', 'Precipitable Water', 'Relative Humidity', 'Mixing Ratio', 'Vapor Pres', 'Spec Hum', 'Theta', 'ThetaE', 'ME', 'RE'];

tabulate("indices", headers, labels, false);

$("#indices tbody tr").each(function(i) {
	$(this).find("td:eq(0)").text(labels[i]);
	//$(this).find("td:eq(2)").text(labels2[i]) GP:MOD;
});
	
}

function interpVal (pres, p_lo, p_hi, lo_val, hi_val) {
	range = (lo_val - hi_val);
	fraction = (p_hi - pres)/(p_hi - p_lo);
	interp = (fraction * range) + hi_val;
	mean = (interp + hi_val) / 2;
	return mean;
}

function calcWetbulb (press, t, dp) // From Interactive Skew-T FLA
{
// Calculates the wetbulb given the pressure (mb), temperature (c), and dewpoint (c)
// This algorithm differs from the one used in the Gary Skaggs program by using a binary-search type approximation
// instead of a brute-force approach. You get a more accurate answer more quickly.
// In an interpreted (slow) language like Javascript, the more efficient the algorithm the better.

	var tmin=dp;
	var vpdp=calcVaporPressure(dp);
	var vpcur;
	var peq;
	var diff;
	var tmax=t;
	var tcur;

	//while (true)
	for(i=0;i<100;i++)
	{
		//trace(i);
		tcur=(tmax+tmin)/2;
		vpcur=calcVaporPressure(tcur);
		peq=0.000660*(1+0.00155*tcur)*press*(t-tcur);
		diff=peq-vpcur+vpdp;
		if (Math.abs(diff) < 0.01)
			break;

		if (diff < 0)
			tmax=tcur;
		else
			tmin=tcur;
	}
	return Math.round(tcur*10)/10;
}

function calcVaporPressure( temp )
{
//	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(temp+273)));
	vp = 6.11 * Math.exp(5321 * (1/273 - 1/(temp+273)));
	return vp;
}

function calcWetbulbZero() // From Interactive Skew-T FLA
{
	var wb0 = 99;
	var wb1 = 99;
	//from the bottom-up, search for the first wb < 0
	for(i=0; i<tlinetest[0][0].length-1; i++){
		wb0 = tlinetest[0][0][i].twc;
		if(wb0 <= 0){
			wb0_index = i;
			break;
		}else{
			wb1 = wb0;
		}
	}
	//establish the range from level to level
	range_fraction = Math.abs(wb0/(wb1 - wb0));
	log_lop = log10(tlinetest[0][0][wb0_index].press);
	if (wb0_index == 0) {
		log_hip = log10(tlinetest[0][0][wb0_index].press);
	} else {
		log_hip = log10(tlinetest[0][0][wb0_index-1].press);
	}
	logp_wb0 = (range_fraction * (log_hip - log_lop)) + log_lop;
	return Math.round(Math.pow(10, logp_wb0));
}

function calcMixingRatio (vapor, press)
{
	return (((0.62197*vapor)/(press-vapor))*1000.0);
}


function calcRelHumidity (ambient, satur)
{
	return Math.round( ambient/satur * 1000)/10;
}

function calcSpecHumidity (vapor, pressure )
{
	return Math.round(100000*0.622*vapor/pressure)/100;
}

function log10(x) {
	return (Math.log(x) / Math.log(10));	
}

function calcLCL(pres, t, dp)
{
//http://www.shodor.org/os411/courses/_master/tools/calculators/lcl/lcl3calc.html
	var P = parseFloat(pres);
	var TK = parseFloat(t) + 273.16;
	var TDK = parseFloat(dp) + 273.16;
	A = 1 / (TDK - 56);
	B = Math.log (TK/TDK)/800;
	var TCK = 1 / (A+B) + 56;
//	var lcl_t = Math.round((TCK-273.15)*10)/10;
	var lcl_t = TCK-273.15;
//	var lcl_p = Math.round(P * Math.pow(TCK / TK, 3.5037));
	var lcl_p = Math.round(P * Math.pow(TCK / TK, 7/2));

	for (i=0; i<tlinetest[0][0].length-1; i++) {
		if (tlinetest[0][0][i].press < lcl_p) {
			p_lo = tlinetest[0][0][i].press;	
			h_lo = tlinetest[0][0][i].hghtagl;	
			break;
		} else if (lcl_p == tlinetest[0][0][i].press) {
			return [lcl_p, lcl_t, tlinetest[0][0][i].hghtagl];
		} else {
			p_hi = tlinetest[0][0][i].press;	
			h_hi = tlinetest[0][0][i].hghtagl;	
		}
	}
	
	var lcl_z = interpVal(lcl_p, p_lo, p_hi, h_lo, h_hi);
	return [lcl_p, lcl_t, lcl_z];
}

function calcCCL()
{
	//calculate the vapor pressure for the parcel
	var vp_pcl = calcVaporPressure(td_pcl100); //parcel vapor pres
	var vp_pcl = calcVaporPressure(tlinetest[0][0][0].mixParcelTd); //parcel vapor pres

	//use that to compute the parcel mixing ratio
	var mr_pcl = calcMixingRatio(vp_pcl, p_pcl100); //parcel mix ratio
	var mr_pcl = calcMixingRatio(vp_pcl, tlinetest[0][0][0].mixParcelP); //parcel mix ratio

	//now, start climbing the temp profile, computing saturation mr at each step.
	//continue until mr_sat is less than mr_pcl.
	//also keep track of previous step
	var smr0 = -1; //current sat mr 
	var smr1 = -1; //previous sat mr

	//loop from bottom up of sounding
	for(i=1; i<tlinetest[0][0].length-1; i++){
//		if(p_pcl100 > tlinetest[0][0][i].press){
		if(tlinetest[0][0][0].mixParcelP > tlinetest[0][0][i].press){
			var svp0 = calcVaporPressure(tlinetest[0][0][i].temp);
			var smr0 = calcMixingRatio(svp0,tlinetest[0][0][i].press) ;

			//calc cat mr along sounding, then compare to pcl mr
			if(smr0 < mr_pcl){
				if(smr1 == -1){//if first calc of sat mr is less than pcl, 
					//then assume that parcel pres is ccl
					pccl = p_pcl100
					pccl = tlinetest[0][0][0].mixParcelP
					tccl = t_pcl100
					tccl = tlinetest[0][0][0].mixParcelT
				}else{
					//otherwise need to interpolate to obtain ccl pressure and temp
					pccl = tlinetest[0][0][i-1].press - ((tlinetest[0][0][i-1].press - tlinetest[0][0][i].press) * (smr1 - mr_pcl)/(smr1 - smr0)); 
					tccl = tlinetest[0][0][i-1].temp - ((tlinetest[0][0][i-1].temp - tlinetest[0][0][i].temp) * (smr1 - mr_pcl)/(smr1 - smr0)); 
				}	
				break;
			}else{
				smr1 = smr0;
			}
		}
	}
	return Math.round(pccl);
}

function calcConvTemp()
{
	theta_ccl = calcTheta(pccl, tccl);
	sfc_p = tlinetest[0][0][0].press;
	ctK = theta_ccl / Math.pow(1000/sfc_p ,0.2854*(1-0.00028*tlinetest[0][0][0].mr));
	ct = ctK - 273.15;
	return Math.round(ct*10)/10;
}

function calcVirtualtemperature(Tc,mixr)
{
	return Math.round(10 * (Tc + (mixr/6.1)))/10; 
}

function calcPrecipWater()
{
	var pw = 0;
	var sh0 = 0;	//current sh
	var p0 = 0;	//current p
	var q0 = 0;	//current q
	var p1 = 0;	//previous p
	var q1 = 0;	//previous q	
	
	for(i=0; i<tlinetest[0][0].length-1; i++){
		dp0 = 273.15 + tlinetest[0][0][i].dwpt;//T=dyntext field
		p0 = tlinetest[0][0][i].press;
		eee = Math.exp(33.09376 - 0.0091379024 * dp0 - 6106.3960 / dp0);
		q0= eee/(p0 - 0.00066771703 * eee);
		q0 = q0 / 1000;//convert to kg/kg
		p0=p0*100;//convert to Pa
		if(i > 0){
			pw += 0.5 * (q0 + q1) * (p1 - p0) * (1/(g * 1000));
		}
		p1=p0;
		q1=q0
	}
	return Math.round(pw * 1000/25.4 *100)/100;
}

function calcSWEAT()
{
	ttdiff = tlinetest[0][0][0].TT - 49;
	if (ttdiff < 0){ttdiff = 0}

	delta_d = wd500 - wd850;
	if (delta_d < 0) {delta_d = 0}

	wind_term = 125*(Math.sin(delta_d * 0.017453293)+0.2);

	if (wd850 >= 130 && wd850 <= 250) {
		wind_term = 0;
	}
	if (wd500 >= 210 && wd500 <= 310) {
		wind_term = 0;
	}
	if (delta_d > 0) {
		wind_term = 0;
	}
	if (ws850 < 15 && ws500 < 15) {
		wind_term = 0;
	}


	if (td850 < 0) {
		term1 = 0;
	} else {
		term1 = 12*td850;
	}

	num = term1 + (20*ttdiff) + (2*ws850) + ws500 + wind_term;
	return Math.round(num);
}

function calcKI()
{
	return Math.round(t850 + td850 - t500 - t700 + td700);
}

function calcTT()
{
	return Math.round(t850 + td850 - (2*t500));
}

function calcFreezeLevel(flag)
{
	var temp0;
	var temp1;
	var temp_frz_t_arr = new Array();
	var logp_temp0_arr = new Array();
	var j = 0;
	for(i=1; i<tlinetest[0][0].length-1; i++){
		if (!flag) {
		temp0 = tlinetest[0][0][i].temp;
		temp1 = tlinetest[0][0][i-1].temp;
		} else {
		temp0 = tlinetest[0][0][i].twc;	
		temp1 = tlinetest[0][0][i-1].twc;
		} 
		if(temp0 <= 0){
			if (i > 0) {
				if (temp1 > 0) { 
					temp_frz_t_arr[j] = [temp0, temp1, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press]; 
					j++;
				}
			}
		}
	}
	for (k=0; k<=temp_frz_t_arr.length-1; k++) {
		//establish the range from level to level
		if (temp_frz_t_arr[k][0] != temp_frz_t_arr[k][1]) {
			range_fraction = Math.abs(temp_frz_t_arr[k][0])/(temp_frz_t_arr[k][1] - temp_frz_t_arr[k][0]);
		} else {
			range_fraction = 1;
		}
		log_lop = log10(temp_frz_t_arr[k][2]); 
		log_hip = log10(temp_frz_t_arr[k][3]); 
		logp_temp0 = (range_fraction * (log_hip - log_lop)) + log_lop;
		logp_temp0_arr.push(Math.round(Math.pow(10, logp_temp0)));
	}
	return logp_temp0_arr;
}

function calcMeltLevel(flag)
{
	var temp0;
	var temp1;
	var temp_frz_t_arr = new Array();
	var logp_temp0_arr = new Array();
	var j = 0;
	for(i=1; i<tlinetest[0][0].length-1; i++){
		if (!flag) {
		temp0 = tlinetest[0][0][i].temp;
		temp1 = tlinetest[0][0][i-1].temp;
		} else {
		temp0 = tlinetest[0][0][i].twc;	
		temp1 = tlinetest[0][0][i-1].twc;
		} 
		if(temp0 >= 0){
			if (i > 0) {
				if (temp1 < 0) { 
					temp_frz_t_arr[j] = [temp0, temp1, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press]; 
					j++;
				}
			}
		}
	}
	for (k=0; k<=temp_frz_t_arr.length-1; k++) {
		//establish the range from level to level
		if (temp_frz_t_arr[k][0] != temp_frz_t_arr[k][1]) {
			range_fraction = Math.abs(temp_frz_t_arr[k][0])/(temp_frz_t_arr[k][1] - temp_frz_t_arr[k][0]);
		} else {
			range_fraction = 1;
		}
		log_lop = log10(temp_frz_t_arr[k][2]); 
		log_hip = log10(temp_frz_t_arr[k][3]); 
		logp_temp0 = (range_fraction * (log_hip - log_lop)) + log_lop;
		logp_temp0_arr.push(Math.round(Math.pow(10, logp_temp0)));
	}
	return logp_temp0_arr;
}

function deg2rad(degrees)
{
	return(degrees * Math.PI / 180);
}

function getBRN(cape)
{
	var u,v,rho;
	var sumu=0;
	var sumv=0;
	var sumz=0;
	var sumu500=0;
	var sumv500=0;	
	var sumrho=0;
	var sumrho500=0;

	for(i=0; i<=tlinetest[0][0].length-1; i++){
		rho = (tlinetest[0][0][i].press*100)/((tlinetest[0][0][i].tv+273.15)*287.05);
		u = tlinetest[0][0][i].wspd*Math.sin(deg2rad(tlinetest[0][0][i].wdir-180));
		v = tlinetest[0][0][i].wspd*Math.cos(deg2rad(tlinetest[0][0][i].wdir-180));
		u_weight = u*rho;
		v_weight = v*rho;

		if (tlinetest[0][0][i].hghtagl >= 6000) { 
			sumz=tlinetest[0][0][i].hghtagl;
			layerz=tlinetest[0][0][i].hghtagl - tlinetest[0][0][i-1].hghtagl;
			var fraction = (6000 - layerz)/sumz;
			u = ((u - uprev) * fraction) + uprev;
			v = ((v - vprev) * fraction) + vprev;
			sumrho += rho;
			sumu += u*rho;
			sumv += v*rho;
			break;
		}

		sumrho += rho;
		sumu += u_weight;
		sumv += v_weight;

		if (tlinetest[0][0][i].hghtagl < 500) { 
			sumrho500 += rho;
			sumu500 += u_weight;
			sumv500 += v_weight;
//			var divisor = i+1;
		}

		uprev = u;
		vprev = v;
	}

	//console.log(sumu, sumv, sumrho, sumrho500)

	u6kmAvg = sumu/sumrho;
	v6kmAvg = sumv/sumrho;
	u500Avg = sumu500/sumrho500;
	v500Avg = sumv500/sumrho500;
	uDiff = (u6kmAvg-u500Avg)*.51444444;
	vDiff = (v6kmAvg-v500Avg)*.51444444;
	mag = Math.sqrt(uDiff**2+vDiff**2);
	brnshr = Math.round((mag**2)*.5);
	brn = Math.round(cape/brnshr);

	return [brn, brnshr];
}

//this function returns BRN and BRNshear
//based on code by Keith Brewster found at this URL:
//http://www.caps.ou.edu/ARPS/arps5Beta8Browser/arps5.0Beta8browser/html_code/adas/thermo3d.f90.html
function getShear(useTv)
{
//	var shear_sum_u=0;
//	var shear_sum_v=0;
//	var thk_sum=0; 
//	var sumu=0;
//	var sumv=0;
//	var sump=0;
	var sumz=0;
	var basez = calcHeightStdAtmos(tlinetest[0][0][0].press);
	var layerz=0;
//	var rholo=0;
	var u_lo=0;
	var v_lo=0;
	//init and calc u and v at the top (lo refers to the density or pressure, not z)
	//var d_hi = deg2rad(270-tlinetest[0][0][0].wdir);
	var d_hi = deg2rad(tlinetest[0][0][0].wdir);
	var u_hi = -tlinetest[0][0][0].wspd * Math.sin(d_hi);
	var v_hi = -tlinetest[0][0][0].wspd * Math.cos(d_hi);
	var dbase = d_hi;
	var ubase = u_hi;
	var vbase = v_hi;

/*	if (d_hi <= Math.PI/2 || (d_hi <= (3*Math.PI)/2 && d_hi > Math.PI)) {
		shear_sum_u=-u_hi;
		shear_sum_v=-v_hi;
	} else if (d_hi <= Math.PI || (d_hi <= 2*Math.PI && d_hi > (3*Math.PI)/2)) {
		shear_sum_u=-v_hi;
		shear_sum_v=-u_hi;
	}
*/

	//iterate from the bottom up.
	for(i=0; i<=tlinetest[0][0].length-1; i++){
	  //calc the thickness of the layer
		//first, find the mean temp
		if (useTv) {
			var t1 = tlinetest[0][0][i].tv;
			var t2 = tlinetest[0][0][i+1].tv;
		} else {
			var t1 = tlinetest[0][0][i].temp;
			var t2 = tlinetest[0][0][i+1].temp;
		}

//		var Tbar = 273.15 + (t1+t2)/2;
		//second, retrieve the pressure at this level (i) and the next one up (i+1)
		var p1 = tlinetest[0][0][i].press;
		var p2 = tlinetest[0][0][i+1].press;
		//last, calculate the layer thickness
		layerz = calcLayerThickness(p1, p2, t1, t2)
		sumz = calcHeightStdAtmos(p2);
//		layerz = ((R * Tbar) / g) * Math.log(p1/p2);
	  //check to see if we're at the 500m level.
	  //check to see if we're above 6000m
		if((sumz - basez) >= 6000){
//			console.log("Std Height, Base Height, Layer Thickness, Height AGL: " + sumz, basez, layerz, sumz-layerz);
			//go into interpolation routine
			//calc the fraction for interpolation
			var fraction = (6000 - layerz)/sumz;
//			console.log(fraction);
			var dp = ((p1-p2)*fraction);
			//now determine the u and v components for the topmost layer, ending at 6 km
			//first get the u and v at the top, above 6 km
			//var dtop = deg2rad(270-tlinetest[0][0][i+1].wdir);
			var dtop = deg2rad(tlinetest[0][0][i+1].wdir);
			var utop = -tlinetest[0][0][i+1].wspd * Math.sin(dtop);
			var vtop = -tlinetest[0][0][i+1].wspd * Math.cos(dtop);
			//next, determine the u and v at 6 km, 
			u_lo = ((utop - u_hi) * fraction) + u_hi;
			v_lo = ((vtop - v_hi) * fraction) + v_hi;
/*			if (d_hi <= Math.PI/2 || (d_hi <= (3*Math.PI)/2 && d_hi > Math.PI)) {
				shear_sum_u += -u_hi;
				shear_sum_v += -v_hi;
			} else if (d_hi <= Math.PI || (d_hi <= 2*Math.PI && d_hi > (3*Math.PI)/2)) {
				shear_sum_u += -v_hi;
				shear_sum_v += -u_hi;
			} else {
				console.log("Wind Direction doesn't fall within 0 and 360 degrees.");
				console.log("d_hi: " + d_hi);
			}
			if (d_lo <= Math.PI/2 || (d_lo <= (3*Math.PI)/2 && d_lo > Math.PI)) {
				shear_sum_u += u_lo;
				shear_sum_v += v_lo;
			} else if (d_lo <= Math.PI || (d_lo <= 2*Math.PI && d_lo > (3*Math.PI)/2)) {
				shear_sum_u += v_lo;
				shear_sum_v += u_lo;
			} else {
				console.log("Wind Direction doesn't fall within 0 and 360 degrees.");
				console.log("d_lo: " + d_lo);
			}
*/

			d_hi = d_lo;
			u_hi = u_lo;
			v_hi = v_lo;

			//add delta p to the running pressure total
//			sump += dp;
//			temp = 1000 - sump;
			//we're done, so break out of the for loop
			break;
		}else{
//			sumz += layerz;
/*			if(tlinetest[0][0][i].press <= 1000){
				thk_sum += layerz;
			}
*/
//			dp = tlinetest[0][0][i].press - tlinetest[0][0][i+1].press;
//			sump += dp;
			//first get the u and v at the top (lo refers to the density or pressure, not z)
			//var d_lo = deg2rad(270-tlinetest[0][0][i+1].wdir);
			var d_lo = deg2rad(tlinetest[0][0][i+1].wdir);
			var u_lo = -tlinetest[0][0][i+1].wspd * Math.sin(d_lo);
			var v_lo = -tlinetest[0][0][i+1].wspd * Math.cos(d_lo);   
/*			if (d_hi <= Math.PI/2 || (d_hi <= (3*Math.PI)/2 && d_hi > Math.PI)) {
				shear_sum_u += -u_hi;
				shear_sum_v += -v_hi;
			} else if (d_hi <= Math.PI || (d_hi <= 2*Math.PI && d_hi > (3*Math.PI)/2)) {
				shear_sum_u += -v_hi;
				shear_sum_v += -u_hi;
			} else {
				console.log("Wind Direction doesn't fall within 0 and 360 degrees.");
				console.log("d_hi: " + d_hi);
			}
			if (d_lo <= Math.PI/2 || (d_lo <= (3*Math.PI)/2 && d_lo > Math.PI)) {
				shear_sum_u += u_lo;
				shear_sum_v += v_lo;
			} else if (d_lo <= Math.PI || (d_lo <= 2*Math.PI && d_lo > (3*Math.PI)/2)) {
				shear_sum_u += v_lo;
				shear_sum_v += u_lo;
			} else {
				console.log("Wind Direction doesn't fall within 0 and 360 degrees.");
				console.log("d_lo: " + d_lo);
			}
*/
			d_hi = d_lo;
			u_hi = u_lo;
			v_hi = v_lo;
		} //end if/then for 6km or not
	}//end for loop
//	console.log(sumz);

/*	console.log("Base (U-comp): " + ubase);
	console.log("Base (V-comp): " + vbase);
	console.log("Top (U-comp): " + utop);
	console.log("Top (V-comp): " + vtop);
*/
	u_shear = utop - ubase;
	v_shear = vtop - vbase;
//	console.log("U and V Shear: " + u_shear, v_shear);
	//console.log(shear_sum_u, shear_sum_v);

	//shear6km = Math.round(Math.sqrt(shear_sum_u**2 + shear_sum_v**2));	
	shear6km = Math.round(Math.sqrt(u_shear**2 + v_shear**2));
	return shear6km;
}

function getCAPE(capeType, useTv)
{
	var el_index = 999;
	var lfc_index = 999;
	var cape = 0;

	if (capeType == "ML") {
		var press_EL = tlinetest[0][0][0].elPmix;
		var press_LFC = tlinetest[0][0][0].lfcPmix;
		var press_LCL = tlinetest[0][0][0].lclPmix;
		var temp_LCL = tlinetest[0][0][0].lclTmix;
		if (useTv) {
			press_EL = tlinetest[0][0][0].elPmix_tv;
			press_LFC = tlinetest[0][0][0].lfcPmix_tv;
			press_LCL = tlinetest[0][0][0].lclPmix_tv;
			temp_LCL = tlinetest[0][0][0].lclTmix_tv;
		}
	} else if (capeType == "SB") {
		var press_EL = tlinetest[0][0][0].elP;
		var press_LFC = tlinetest[0][0][0].lfcP;
		var press_LCL = tlinetest[0][0][0].lclP;
		var temp_LCL = tlinetest[0][0][0].lclT;
		if (useTv) {
			press_EL = tlinetest[0][0][0].elP_tv;
			press_LFC = tlinetest[0][0][0].lfcP_tv;
			press_LCL = tlinetest[0][0][0].lclP_tv;
			temp_LCL = tlinetest[0][0][0].lclT_tv;
		}
	} else if (capeType == "Moist Adiabats") {
		var press_EL = 100;
		var press_LFC = 1000;
		var press_LCL = 1000;
		var temp_LCL = 10;
	} else {
		var press_EL = tlinetest[0][0][0].elP;
		var press_LFC = tlinetest[0][0][0].lfcP;
		var press_LCL = tlinetest[0][0][0].lclP;
		var temp_LCL = tlinetest[0][0][0].lclT;
	}

//if(tlinetest[0][0][0].elP != 0){	
	//let's start by wiping the parcel_temp_array
	for(i in parcel_temp_array){
		parcel_temp_array[i] = null;	
	}
	//and reinitializing
	var sumCAPE = 0;
	//starting from the top down
	//find the first obs level below the EL
	for(i=tlinetest[0][0].length-1; i>=0; i--){
		if(tlinetest[0][0][i].press > press_EL){
			el_index = i;
			break;
		}
	}
	//starting from the bottom up
	//find the first obs level above the LFC
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if(tlinetest[0][0][i].press < press_LFC){
			lfc_index = i;
			break;
		}
	}
	//starting from the bottom up
	//find the first obs level above the LCL
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if(tlinetest[0][0][i].press < press_LCL){
			lcl_index = i;
			break;
		}
	}

	//let's populate an array with tempC's along the parcel line (temp then moist adiabat)
	for(i=tlinetest[0][0].length-1; i>=0; i--){
		if (i < lcl_index) {
			theta_lcl = calcTheta(press_LCL,temp_LCL);
			parcel_temp_array[i] = theta2C(theta_lcl, tlinetest[0][0][i].press)
		} else {
			//get the parcel temperature at the current level
			thetae_lcl=calcThetaE(press_LCL, temp_LCL, temp_LCL);
			temp_t = findTC(thetae_lcl, tlinetest[0][0][i].press);
			//drop it into an array
			parcel_temp_array[i] = temp_t;
		}

		if(i==el_index){//starting at the EL and working down
			//mean obs temp of the layer
			if (useTv) {
				mean_t = (tlinetest[0][0][el_index].tv + temp_t) / 2;
			} else {
				mean_t = (tlinetest[0][0][el_index].temp + temp_t) / 2;
			}
			//thickness of the layer
			if (!press_EL) {
			} else {
				dz = calcThickness(tlinetest[0][0][i].press, press_EL, mean_t);
				//dt is the diff between pcl temp and obs temp (C) used to compute area
				if (useTv) {
					dt = (temp_t - tlinetest[0][0][i].tv) / 2;//it's a triangle, so divide dt by 2 to get the proper area
				} else {
					dt = (temp_t - tlinetest[0][0][i].temp) / 2;//it's a triangle, so divide dt by 2 to get the proper area
				}

				sumCAPE += (dz * dt) / (mean_t + 273.15);
			}
		}else if (i==lfc_index){//now check to see if we're at the LFC
			tlfc = findTC(thetae_lcl, press_LFC);//get temp at LFC
			mean_t = (tlfc + temp_t) / 2; //get layer mean temp
			dz = calcThickness(press_LFC, tlinetest[0][0][i].press, mean_t);//get layer thickness
			if (useTv) {
				dt = (temp_t - tlinetest[0][0][i].tv) / 2;//get pcl/obs temp diff
			} else {
				dt = (temp_t - tlinetest[0][0][i].temp) / 2;//get pcl/obs temp diff
			}

			sumCAPE += (dz * dt) / (mean_t + 273.15); //add to sum
		}else if (i<el_index && i>lfc_index) { //in the middle, between the EL and LFC
			if (useTv) {
//				mean_t = (tlinetest[0][0][i].tv + tlinetest[0][0][i+1].tv) / 2;
				mean_t = (temp_t + tlinetest[0][0][i].tv) / 2;
			} else {
				mean_t = (temp_t + tlinetest[0][0][i].temp) / 2;
			}

			dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][i+1].press, mean_t);
			if (useTv) {
				dt0 = temp_t - tlinetest[0][0][i].tv;// pcl temp - obs temp at current level
				dt1 = parcel_temp_array[i+1] - tlinetest[0][0][i+1].tv;// pcl temp - obs temp at level above
			} else {
				dt0 = temp_t - tlinetest[0][0][i].temp;// pcl temp - obs temp at current level
				dt1 = parcel_temp_array[i+1] - tlinetest[0][0][i+1].temp;// pcl temp - obs temp at level above
			}

			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCAPE += (dz * mean_dt) / (mean_t + 273.15);// add to sum
		} else {
		}
	}
	var cape = g * sumCAPE; //multiply time g to get cape

	if(cape <= 0){
		cape = 0;//if cape<0, then set it to 0
	}
	cinArray = getCIN(parcel_temp_array, capeType, useTv);
	cin = cinArray[0];
	brn_arr = getBRN(cape, useTv); //calculate BRN
	shear = getShear(useTv);

	return [Math.round(cape), parcel_temp_array, cin, brn_arr, shear]; //return a value - gets posted in parameters

}

function getBourg(bourgType)
{
	var posEnergy = 0;
	var negEnergy = 0;
	var sumPosEnergy = 0;
	var sumNegEnergy = 0;

	//starting from the top down
	//find the first obs level below the press_top
	for(i=tlinetest[0][0].length-1; i>=0; i--){
		if(tlinetest[0][0][i].twc >= 0){
			var frzIndices = [i];
			break;
		}
	}

	//find the obs levels crossing zero below the top of the Melting Energy section;
	if (!frzIndices) {
		console.log("No positive temps");
	}else {
		for(i=frzIndices[0]-1; i>=0; i--) {
//			console.log(frzIndices.length % 2);
			if (frzIndices.length % 2 == 0) {
				if(tlinetest[0][0][i].twc >= 0){
					frzIndices.push(i);
//					console.log(tlinetest[0][0][i].twc, i);
				}
			} else {
				if(tlinetest[0][0][i].temp <= 0){
					frzIndices.push(i);
//					console.log(tlinetest[0][0][i].twc, i);
				}
			}
		}

		console.log(frzIndices);

		wbzLen = tlinetest[0][0][0].wbz.length;
		wbmeltLen = tlinetest[0][0][0].wbmelt.length;

		for(i=frzIndices[0]; i>=0; i--){
			if(i==frzIndices[0]){//starting at the top of the melting layer and working down // TOP TRIANGLE
				//mean obs wet-bulb temp of the layer
				mean_t = (tlinetest[0][0][i].twc) / 2;
				//thickness of the layer
				dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][0].wbz[wbzLen-1], mean_t);
				//dt is the diff between obs wet-bulb temp (C) and zero used to compute area
//				dt = (tlinetest[0][0][i].twc) / 2; //it's a triangle, so divide dt by 2 to get the proper area
				dt = (tlinetest[0][0][i].twc);

				sumPosEnergy += (dz * dt) / (mean_t + 273.15);
				console.log("Positive: " + sumPosEnergy + ", " + i);

			}else if (i==frzIndices[1]){//now check to see if we're at the "middle" indices // BOTTOM AND TOP TRIANGLE
				tmid = tlinetest[0][0][i+1].twc;//get wet-bulb temp at middle index
				mean_t = (tmid) / 2; //get layer mean wet-bulb temp
				dz = calcThickness(tlinetest[0][0][i+1].press, tlinetest[0][0][0].wbmelt[wbmeltLen-1], mean_t);//get layer thickness
//				dt = mean_t/2; //get 0 to obs wet-bulb temp diff. Because it is a triangle, divide by two.
				dt = mean_t;

				sumPosEnergy += (dz * dt) / (mean_t + 273.15); //add to sum
				console.log("Positive: " + sumPosEnergy + ", " + i);
			
				tmid = tlinetest[0][0][i].twc;//get wet-bulb temp at middle index
				mean_t = (tmid) / 2; //get layer mean wet-bulb temp
				dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][0].wbmelt[wbmeltLen-1], mean_t);//get layer thickness
//				dt = mean_t/2; //get 0 to obs wet-bulb temp diff. Because it is a triangle, divide by two.
				dt = mean_t;

				sumNegEnergy += (dz * dt) / (mean_t + 273.15); //add to sum
				console.log("Negative: " + sumNegEnergy + ", " + i);

			}else if ((i<frzIndices[0] && i>frzIndices[1]) || (i<frzIndices[0] && !frzIndices[1]) || 
				(i<frzIndices[2] && i>frzIndices[3]) || (i<frzIndices[2] && !frzIndices[3])) { //in the middle, between the top and mid // TRAPEZOID
				mean_t = (tlinetest[0][0][i+1].twc + tlinetest[0][0][i].twc) / 2;
				dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][i+1].press, mean_t);
				dt0 = tlinetest[0][0][i].twc;// difference of obs wet-bulb temp at current level and 0˚C.
				dt1 = tlinetest[0][0][i+1].twc;// difference of obs wet-bulb temp at level above and 0˚C.

				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumPosEnergy += (dz * mean_dt) / (mean_t + 273.15);// add to sum
				console.log("Positive: " + sumPosEnergy + ", " + i);

			}else if (i==frzIndices[2]) { // BOTTOM AND TOP TRIANGLE
				tmid = tlinetest[0][0][i+1].twc;//get wet-bulb temp at middle index
				mean_t = (tmid) / 2; //get layer mean temp
				dz = calcThickness(tlinetest[0][0][0].wbz[wbzLen-2], tlinetest[0][0][i+1].press, mean_t);//get layer thickness
				dt = tlinetest[0][0][i+1].twc;//get 0 to obs temp diff

				sumNegEnergy += (dz * dt) / (mean_t + 273.15); //add to sum
				console.log("Negative: " + sumNegEnergy + ", " + i);

				tmid = tlinetest[0][0][i].twc;//get wet-bulb temp at middle index
				mean_t = (tmid) / 2; //get layer mean temp
				dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][0].wbz[wbzLen-2], mean_t);//get layer thickness
				dt = tlinetest[0][0][i].twc;//get 0 to obs temp diff

				sumPosEnergy += (dz * dt) / (mean_t + 273.15); //add to sum
				console.log("Positive: " + sumPosEnergy + ", " + i);

			}else if ((i<frzIndices[1] && i>frzIndices[2]) || (i<frzIndices[1] && !frzIndices[2])) { // TRAPEZOID
				mean_t = (tlinetest[0][0][i+1].twc + tlinetest[0][0][i].twc) / 2;
				dz = calcThickness(tlinetest[0][0][i].press, tlinetest[0][0][i+1].press, mean_t);
				dt0 = tlinetest[0][0][i].twc;// obs wet-bulb temp at current level
				dt1 = tlinetest[0][0][i+1].twc;// obs wet-bulb temp at level above

				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumNegEnergy += (dz * mean_dt) / (mean_t + 273.15);// add to sum
				console.log("Negative: " + sumNegEnergy + ", " + i);

			} else {

			}
		}
	}

	var posEnergy = g * sumPosEnergy; //multiply time g to get J/kg
	var negEnergy = g * sumNegEnergy; //multiply time g to get J/kg

	console.log(posEnergy, negEnergy);

	var probSN;
	var probPL;
	var probFRZA;
	var probRA;

	return [Math.round(posEnergy),Math.round(negEnergy)]; //return a value - gets posted in parameters

}

/**********************************************************************/
function calcTheta(P,T)
{
	//trace("calcTheta")
	num = (T + 273.15) * Math.pow(1000/P ,0.286);
	return Math.round(num*10)/10;
}

function calcTC(P,Theta)
{
	num = Theta / Math.pow(1000/P ,0.286);
	return Math.round((num-273.15)*10)/10;
}

function theta2C(thetaK,P)
/*
based on function TDA at http://wahiduddin.net/calc/density_algorithms.htm
RETURNS THE TEMPERATURE TDA (CELSIUS) ON A DRY ADIABAT
AT PRESSURE P (MILLIBARS). THE DRY ADIABAT IS GIVEN BY
POTENTIAL TEMPERATURE O (CELSIUS).
*/
{
	//var thetaK= theta+273.15;
	//var TDAK= thetaK*((P*.001)**.286);
	var TDAK= thetaK * Math.pow(P*.001,0.286)
	var TDA= TDAK-273.15;
	return Math.round(TDA*10)/10;
}
/**********************************************************************/

function getCIN(t_arr, flag, useTv) {
	lfc_index = 0;
	//first off, let's see if the lfc lies within our BL
	//if so, then cin = 0, so we return 0, which concludes the function.
	if (flag == "ML") {
		if (useTv) {
			if(tlinetest[0][0][0].lfcPmix_tv >= tlinetest[0][0][0].mixParcelP_tv - bl_depth/2 || tlinetest[0][0][0].lfcPmix_tv == -1){
				cin = 0;
				return [cin];
			}
			lfc_press = tlinetest[0][0][0].lfcPmix_tv;
			lfc_temp = tlinetest[0][0][0].lfcTmix_tv;
			lcl_press = tlinetest[0][0][0].lclPmix_tv;
			lcl_temp = tlinetest[0][0][0].lclTmix_tv;

			//now let's find the first level above the top of the mixed layer
			for(i=0; i<tlinetest[0][0].length-1; i++){
				if(tlinetest[0][0][i].press <= tlinetest[0][0][0].mixParcelP_tv - bl_depth/2){
					pcl_index = i;
					break;
				}
			}
		} else {
			if(tlinetest[0][0][0].lfcPmix >= tlinetest[0][0][0].mixParcelP - bl_depth/2 || tlinetest[0][0][0].lfcPmix == -1){
				cin = 0;
				return [cin];
			}
			lfc_press = tlinetest[0][0][0].lfcPmix;
			lfc_temp = tlinetest[0][0][0].lfcTmix;
			lcl_press = tlinetest[0][0][0].lclPmix;
			lcl_temp = tlinetest[0][0][0].lclTmix;

			//now let's find the first level above the top of the mixed layer
			for(i=0; i<tlinetest[0][0].length-1; i++){
				if(tlinetest[0][0][i].press <= tlinetest[0][0][0].mixParcelP - bl_depth/2){
					pcl_index = i;
					break;
				}
			}
		}

	
	} else {
		if (useTv) {
			lfc_press = tlinetest[0][0][0].lfcP_tv;
			lfc_temp = tlinetest[0][0][0].lfcT_tv;
			lcl_press = tlinetest[0][0][0].lclP_tv;
			lcl_temp = tlinetest[0][0][0].lclT_tv;
			pcl_index = 0;
		} else {
			lfc_press = tlinetest[0][0][0].lfcP;
			lfc_temp = tlinetest[0][0][0].lfcT;
			lcl_press = tlinetest[0][0][0].lclP;
			lcl_temp = tlinetest[0][0][0].lclT;
			pcl_index = 0;
		}
	}
	//and reinitializing
	var sumCIN = 0;

	//starting from the top down
	//find the first obs level below the LFC
	for(i=tlinetest[0][0].length-1; i>0; i--){
		if(tlinetest[0][0][i].press > lfc_press){
			lfc_index = i;
			break;
		}
	}
	for(i=tlinetest[0][0].length-1; i>0; i--){
		if(tlinetest[0][0][i].press > lcl_press){
			lcl_index = i;
			break;
		}
	}
	//let's populate an array with parcel tempC's 
	//along the moist adiabat above the LCL
	//along a dry adiabat below the LCL

	//now start the computation...
	//first, a little short hand
	if (flag =="ML") {
		var pcl_press = tlinetest[0][0][pcl_index].press; //pressure at the pcl_index
		if (useTv) {
			var pblt = tlinetest[0][0][0].mixParcelP_tv - bl_depth/2; //pressure at the top of the boundary layer = 
		} else {
			var pblt = tlinetest[0][0][0].mixParcelP - bl_depth/2; //pressure at the top of the boundary layer = 
		}

	} else {
		if (useTv) {
			var pblt = tlinetest[0][0][0].mixParcelP_tv - bl_depth/2; //pressure at the top of the boundary layer = 			
		} else {
			var pblt = tlinetest[0][0][0].mixParcelP - bl_depth/2; //pressure at the top of the boundary layer = 
		}
		var pcl_press = tlinetest[0][0][0].press;

	}

	//first we see if there is any cin between the pcl_index level, where we will start our calculation
		if(pcl_press < pblt){
			//first we need the obs t and pcl t at the top of the boundary layer
			//get this through interpolation
			//first the obs temp
			pHi = tlinetest[0][0][pcl_index-1].press; //(base of layer)
			pLo = pcl_press;//pressure at pcl_index (top of layer)
			if (useTv) {
				tHi = tlinetest[0][0][pcl_index-1].tv; 
				tLo = tlinetest[0][0][pcl_index].tv;
			} else {
				tHi = tlinetest[0][0][pcl_index-1].temp; 
				tLo = tlinetest[0][0][pcl_index].temp;
			}

			fraction = (pHi-pblt) / (pHi-pLo); 
			tblt_obs =  tHi - (fraction * (tHi - tLo));//obs t at BL top
			//now the pcl temp
			//first, we have to establish where the lcl is relative to the top of the BL (or BLT)
			if(lcl_press < pcl_press || lcl_press >= pcl_press){
				pHi = tlinetest[0][0][0].press; //pressure at BL center
				pLo = tlinetest[0][0][lcl_index].press;//pressure at pcl_index
				if (useTv) {
					tHi = tlinetest[0][0][0].tv; //temp at BL center
					tLo = tlinetest[0][0][lcl_index].tv; // temp at pcl_index level
				} else {
					tHi = tlinetest[0][0][0].temp; //temp at BL center
					tLo = tlinetest[0][0][lcl_index].temp; // temp at pcl_index level
				}

			}else if(pcl_press <= lcl_press && lcl_press <= pblt){
				pHi = tlinetest[0][0][0].press; //pressure at BL center (base of layer)
				pLo = lcl_press; //pressure at lcl
				if (useTv) {
					tHi = tlinetest[0][0][0].tv; //temp at BL center
				} else {
					tHi = tlinetest[0][0][0].temp; //temp at BL center
				}

				tLo = lcl_temp; // temp at lcl
			}else if(pcl_press <= pblt && pblt <= lcl_press){
				pHi = lcl_press;//pressure at lcl
				pLo = pcl_press;//pressure at pcl_index (top of layer)
				tHi = lcl_temp; //temp at lcl
				tLo = t_arr[pcl_index];// temp at pcl_index level
			}
			fraction = (pHi-pblt) / (pHi-pLo); 
			tblt_pcl =  tHi - (fraction * (tHi - tLo));//obs t at BL top
	
			//now we're prepared to calculate cin for this layer
			//first check whether plfc >pcl_press 
			//if so, use plfc as the top, else use pcl_press as the top
			if(lfc_press > pcl_press){
				mean_t = (lfc_temp + tblt_obs) / 2;
				dz = calcThickness(pblt, lfc_press, mean_t);
				dt0 = 0;// pcl temp - obs temp at level above
				dt1 = tblt_pcl - tblt_obs;// // pcl temp - obs temp at present level
				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
				//since we just computed from the blt to the lfc, we're done.
				//finish computation and return value
				var cin = g * sumCIN; //multiply time g to get cape
				return Math.round(cin); //return a value - gets posted in parameters
			}else{
				mean_t = (tlinetest[0][0][pcl_index].temp + tblt_obs) / 2;
				dz = calcThickness(pblt, pcl_press, mean_t);
				if (useTv) {
					dt0 = t_arr[pcl_index+1] - tlinetest[0][0][pcl_index+1].tv;// pcl temp - obs temp at level above
				} else {
					dt0 = t_arr[pcl_index+1] - tlinetest[0][0][pcl_index+1].temp;// pcl temp - obs temp at level above
				}

				dt1 = tblt_pcl - tblt_obs;// // pcl temp - obs temp at present level
				mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
				sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
			}
		}	
	//next we integrate from the pcl_index up to just short of the triangle topped by the lfc, which we will treat seperately at the end
//	for(i=pcl_index; i<lfc_index; i++){
	for(i=0; i<lfc_index; i++){
		//case 1 - entire layer either above or below lcl
		if(tlinetest[0][0][i+1].press > lcl_press || tlinetest[0][0][i].press < lcl_press){
			if (useTv) {
				mean_t = (tlinetest[0][0][i].tv + tlinetest[0][0][i+1].tv) / 2; //need tlcl_obs
			} else {
				mean_t = (tlinetest[0][0][i].temp + tlinetest[0][0][i+1].temp) / 2; //need tlcl_obs
			}
			dz = calcThickness(tlinetest[0][0][i].press,tlinetest[0][0][i+1].press, mean_t);
			if (useTv) {
				dt0 = t_arr[i+1] - tlinetest[0][0][i+1].tv;// pcl temp - obs temp at level above
				dt1 = t_arr[i] - tlinetest[0][0][i].tv;// // pcl temp - obs temp at present level
			} else {
				dt0 = t_arr[i+1] - tlinetest[0][0][i+1].temp;// pcl temp - obs temp at level above
				dt1 = t_arr[i] - tlinetest[0][0][i].temp;// // pcl temp - obs temp at present level
			}

			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum

		} else { //layer straddles the lcl
			//first find the observed temp at the lcl
			pHi = tlinetest[0][0][i].press;
			pLo = tlinetest[0][0][i+1].press;
			if (useTv) {
				tHi = tlinetest[0][0][i].tv;
				tLo = tlinetest[0][0][i+1].tv;
			} else {
				tHi = tlinetest[0][0][i].temp;
				tLo = tlinetest[0][0][i+1].temp;				
			}
			fraction = (pHi-lcl_press) / (pHi-pLo);
			tlcl_obs =  tHi - (fraction * (tHi - tLo))//obs t at LCL
			//now compute from the base of the layer up to the lcl
			mean_t = (tHi + tlcl_obs) / 2;
			dz = calcThickness(pHi, lcl_press, mean_t);
			dt0 = lcl_temp - tlcl_obs;// pcl temp - obs temp at LCL
			if (useTv) {
				dt1 = t_arr[i] - tlinetest[0][0][i].tv;// // pcl temp - obs temp at present level
			} else {
				dt1 = t_arr[i] - tlinetest[0][0][i].temp;// // pcl temp - obs temp at present level
			}
			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
			//now compute from the lcl to the top of the layer
			mean_t = (tLo + tlcl_obs) / 2;
			dz = calcThickness(lcl_press, pLo, mean_t);
			dt0 = lcl_temp - tlcl_obs;// pcl temp - obs temp at LCL
			if (useTv) {
				dt1 = t_arr[i+1] - tlinetest[0][0][i+1].tv;// // pcl temp - obs temp at level above present level
			} else {
				dt1 = t_arr[i+1] - tlinetest[0][0][i+1].temp;// // pcl temp - obs temp at level above present level
			}

			mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
			sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
		}
	}

	//now, the last bit up to the lfc
	if (useTv) {
		mean_t = (lfc_temp + tlinetest[0][0][lfc_index].tv) / 2; //need tlcl_obs
	} else {
		mean_t = (lfc_temp + tlinetest[0][0][lfc_index].temp) / 2; //need tlcl_obs
	}

	dz = calcThickness(tlinetest[0][0][lfc_index].press, lfc_press, mean_t);
	dt0 = 0;// pcl temp = obs temp at lfc, so dt0=0
	if (useTv) {
		dt1 = t_arr[lfc_index] - tlinetest[0][0][lfc_index].tv;// // pcl temp - obs temp at present level
	} else {
		dt1 = t_arr[lfc_index] - tlinetest[0][0][lfc_index].temp;// // pcl temp - obs temp at present level
	}

	mean_dt = (dt0 + dt1) / 2; //avg of 2 dt's
	sumCIN += (dz * mean_dt) / (mean_t + 273.15);// add to sum
//	lfc_cin = g*(dz * mean_dt) / (mean_t + 273.15);
	//finish up...
	var cin = g * sumCIN; //multiply time g to get cin
	if(cin > 0 || cin === undefined || isNaN(cin)) {
		cin = 0;
	}

	return [Math.round(cin)]; //return a value - gets posted in parameters
}
/***************************************************************/
function calcThickness(p1, p2, t)
{
	//the crux of this is finding the mean temp for the layer
	//otherwise, the calculation is pretty simple: z2-z1 = (R*T/g)*ln(p2/p1);
	Tbar = 273.15 + t;
	delta_z = ((R * Tbar) / g) * Math.log(p1/p2);
	return Math.round(delta_z);
}

function calcLayerThickness(p1, p2, t1, t2) {
	Tbar = ((273.15 + t1) + (273.15 + t2))/2;
	delta_z = ((R * Tbar) / g) * Math.log(p1/p2);
	return Math.round(delta_z);
}

function calcHeightStdAtmos(pres) {
	var p0 = 1013.25;
	var t0 = 288;
	var Rd = 287;
	var g = 9.8;

	gamma = .0065
    return (t0 / gamma) * (1 - (pres / p0)**(
        Rd * gamma / g))
}

function calcThick()
{
	//the crux of this is finding the mean temp for the layer
	//otherwise, the calculation is pretty simple: z2-z1 = (R*T/g)*ln(p2/p1);
	var sum_t = 0;
	var sum_p = 0;
	var p1 = 1000;
	var p2 = 500;
	var index_1000;
	for(i=0; i<tlinetest[0][0].length-1; i++){
		if (tlinetest[0][0][i].press < 1000 && index_1000 == undefined) {
			index_1000 = i;
		}
		if(tlinetest[0][0][i].press == 1000){
			index_1000 = i;
		}else if(tlinetest[0][0][i].press < 500){
			index_500 = i;
		}
	}
	
	for(i=index_1000; i<index_500; i++){
		layer_t = (tlinetest[0][0][i].temp + tlinetest[0][0][i+1].temp) / 2;
		delta_p = tlinetest[0][0][i+1].press - tlinetest[0][0][i].press;
		sum_t += layer_t * delta_p;
		sum_p += delta_p;
	}
	Tbar = 273.15 + (sum_t / sum_p);
	delta_z = ((R * Tbar) / g) * Math.log(p1/p2);
	return Math.round(delta_z);
}

//this function assigns values for ppcl, tpcl, and tdpcl
function getParcelVals(flag) {
	//initialize vars
	var delta_p = 0;
	var fraction = 0;
	
	var mean_t = 0;
	var weighted_mean_t = 0;
	var t_range = 0;
	var t_interp = 0;
	
	var mean_td = 0;
	var weighted_mean_td = 0;
	var td_range = 0;
	var td_interp = 0;
			
	//start by getting the values at the lowest level
	var hi_p = tlinetest[0][0][0].press;
	//var temp0 = _parent.obs_array[_parent.obs_array.length-1].t;
	//var td0 = _parent.obs_array[_parent.obs_array.length-1].td;
	
	//now search upward and grab values for the next 100 mb up.
	//interpolate if necessary
	for(i=1; i<tlinetest[0][0].length; i++){
		if(hi_p - tlinetest[0][0][i].press <= bl_depth){ // 100mb is the mixing length right now, but could make this any value.
			delta_p = tlinetest[0][0][i-1].press - tlinetest[0][0][i].press;
			if (flag == "Tv") {
				mean_t = (tlinetest[0][0][i-1].tv + tlinetest[0][0][i].tv) / 2;
			} else {
				mean_t = (tlinetest[0][0][i-1].temp + tlinetest[0][0][i].temp) / 2;
			}
			weighted_mean_t += mean_t * delta_p;
			//same for dewpoint
			mean_td = (tlinetest[0][0][i-1].dwpt + tlinetest[0][0][i].dwpt) / 2;
			weighted_mean_td += mean_td * delta_p;
			//if we fall right on 100, then break out of for loop
// Maybe == isn't what is needed here... //
			if(hi_p - tlinetest[0][0][i].press == bl_depth){ // 100mb is the mixing length right now, but could make this any value.
				break;	
			}
		} else {
			//interpolate the temp 100 mb above sfc
			fraction = (tlinetest[0][0][i-1].press - hi_p + bl_depth) / (tlinetest[0][0][i-1].press - tlinetest[0][0][i].press);// 100mb is the mixing length right now, but could make this any value.
			delta_p = tlinetest[0][0][i-1].press - (hi_p - bl_depth);// 100mb is the mixing length right now, but could make this any value.
			//interpolate temp
			if (flag == "Tv") {
				t_range = (tlinetest[0][0][i].tv - tlinetest[0][0][i-1].tv);
				t_interp = (fraction * t_range) + tlinetest[0][0][i-1].tv;
				mean_t = (t_interp + tlinetest[0][0][i-1].tv) / 2;
			} else {
				t_range = (tlinetest[0][0][i].temp - tlinetest[0][0][i-1].temp);
				t_interp = (fraction * t_range) + tlinetest[0][0][i-1].temp;
				mean_t = (t_interp + tlinetest[0][0][i-1].temp) / 2;
			}

			weighted_mean_t += mean_t * delta_p;
			//same for dewpoint
			td_range = (tlinetest[0][0][i].dwpt - tlinetest[0][0][i-1].dwpt);
			td_interp = (fraction * td_range) + tlinetest[0][0][i-1].dwpt;
			mean_td = (td_interp + tlinetest[0][0][i-1].dwpt) / 2;
			weighted_mean_td += mean_td * delta_p;

			//break out of for loop
			break;
		}
	}
	ppcl = hi_p-bl_depth/2;
	tpcl = weighted_mean_t / bl_depth;
	tdpcl = weighted_mean_td / bl_depth;

	return [ppcl, tpcl, tdpcl];
}

function findLFCandEL(flag)
{
	if (flag == "ML") {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclPmix, tlinetest[0][0][0].lclTmix, tlinetest[0][0][0].lclTmix);
		tlinetest[0][0][0].thetaE_LCLmix = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclPmix,tlinetest[0][0][0].lclTmix);
		tlinetest[0][0][0].theta_LCLmix = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclPmix;
	} else if (flag == "MLTv") {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclPmix_tv, tlinetest[0][0][0].lclTmix_tv, tlinetest[0][0][0].lclTmix_tv);
		tlinetest[0][0][0].thetaE_LCLmix_tv = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclPmix_tv,tlinetest[0][0][0].lclTmix_tv);
		tlinetest[0][0][0].theta_LCLmix_tv = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclPmix_tv;
	} else if (flag == "SBTv") {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclP_tv, tlinetest[0][0][0].lclT_tv, tlinetest[0][0][0].lclT_tv);
		tlinetest[0][0][0].thetaE_LCL_tv = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclP_tv,tlinetest[0][0][0].lclT_tv);
		tlinetest[0][0][0].theta_LCL_tv = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclP_tv;
	} else {
		thetae_lcl=calcThetaE(tlinetest[0][0][0].lclP, tlinetest[0][0][0].lclT, tlinetest[0][0][0].lclT);
		tlinetest[0][0][0].thetaE_LCL = thetae_lcl;
		theta_lcl = calcTheta(tlinetest[0][0][0].lclP,tlinetest[0][0][0].lclT);
		tlinetest[0][0][0].theta_LCL = theta_lcl;
		lcl_press = tlinetest[0][0][0].lclP;
	}
	//now find the observed temp at LCL by interpolation
	for(i=1; i<tlinetest[0][0].length; i++){
	//working from the bottom up, look for place where pressure is less than pressure at lcl
		p_lo = tlinetest[0][0][i].press;
		p_hi = tlinetest[0][0][i-1].press
		if (tlinetest[0][0][i].press < lcl_press){
			t_lo = tlinetest[0][0][i].temp;
			t_hi = tlinetest[0][0][i-1].temp;
			if (flag == "ML") {
				lcl_press = tlinetest[0][0][0].lclPmix;
				lcl_temp = tlinetest[0][0][0].lclTmix;
			} else if (flag == "MLTv") {
				lcl_press = tlinetest[0][0][0].lclPmix_tv;
				lcl_temp = tlinetest[0][0][0].lclTmix_tv;
			} else if (flag == "SBTv") {
				lcl_press = tlinetest[0][0][0].lclP_tv;
				lcl_temp = tlinetest[0][0][0].lclT_tv;
			} else {
				lcl_press = tlinetest[0][0][0].lclP;
				lcl_temp = tlinetest[0][0][0].lclT;
			}
			var start_index = i;
			break;
		}
	}
	var lfc_index = -1;
	var zlfc = -1;

	//now interpolate to find the observed temp at the lcl
	fraction = (p_hi - lcl_press)/(p_hi - p_lo);
	obs_tlcl = t_hi - (fraction * (t_hi - t_lo));// + t_hi;
	//check if tlcl is greater than observed temp.
	//if so, lfc = lcl
	if(lcl_temp >= obs_tlcl){
		plfc = lcl_press;
		zlfc = tlinetest[0][0][0].lclZ; // This line might be weird with the new flag system.
		tlfc = Math.round(lcl_temp*10)/10; // This line might be weird with the new flag system.
		lfc_index = i;
	//otherwise start moving up the sounding from the lcl.
	//determine the parcel temp at each obs point, 
	//and check if parcel is greater than the obs temp.
	}else{
		var tempP_hi = tlinetest[0][0][start_index].press;
		if (flag == "MLTv" || flag == "SBTv") {
			var obsT_hi = tlinetest[0][0][start_index].tv;
		} else {
			var obsT_hi = tlinetest[0][0][start_index].temp;
		}
		var obsZ_hi = tlinetest[0][0][start_index].hghtagl;
		var pclT_hi = findTC(thetae_lcl, tempP_hi);
		for (i=start_index; i<tlinetest[0][0].length-1; i++){
			tempP_lo = tlinetest[0][0][i].press;
			if (flag == "MLTv" || flag == "SBTv") {
				obsT_lo = tlinetest[0][0][i].tv;
			} else {
				obsT_lo = tlinetest[0][0][i].temp;
			}

			obsZ_lo = tlinetest[0][0][i].hghtagl;
			pclT_lo = findTC(thetae_lcl, tempP_lo);
			if (pclT_lo > obsT_lo) { 
				//NEW WAY: force to small number (0.1) if isothermal layer:
				if(obsT_hi - obsT_lo != 0){
					m_obs = (tempP_hi - tempP_lo) / (obsT_hi - obsT_lo);
				}else{
					m_obs = (tempP_hi - tempP_lo) / (0.1);
				}
				if(pclT_hi - pclT_lo != 0){
					m_pcl = (tempP_hi - tempP_lo) / (pclT_hi - pclT_lo);
				}else{
					m_pcl = (tempP_hi - tempP_lo) / (0.1);
				}
				if (m_obs == 0 &&  m_pcl == 0) {
					plfc = lcl_press;
					tlfc = lcl_temp;
					break;
				} 
				//now set up obs lines as ax + by = c
				a = m_obs;
				b = 1;
				c = (m_obs * obsT_hi) - tempP_hi;
				//set up parcel line as dx + ey = f
				d = m_pcl;
				e = 1;
				f = (m_pcl * pclT_hi) - tempP_hi;
				//now some linear algebra
				//find 3 determinates of matrices
				det1 = (a*e)-(b*d);
				det2 = (c*e)-(b*f);
				det3 = (a*f)-(c*d);
				//finally solve for plfc and tlfc
				tlfc = Math.round(det2/det1*10)/10;
				plfc = Math.round(-1*det3/det1);//not sure why the negative sign here, but it appears to work...
				zlfc = interpVal(plfc, tempP_lo, tempP_hi, obsZ_lo, obsZ_hi);
				break;
			}else{
				tempP_hi = tempP_lo;
				obsT_hi = obsT_lo;
				pclT_hi = pclT_lo;
				//what if there is NO LFC???
				if (i == tlinetest[0][0].length-2) {
					plfc = -1;
				}
			}			
		}
		lfc_index = i;
		if (plfc == -1) {
			lfc_index = -1;
			zlfc = -1;
		}
	}
	//now find the EL by searching from the top down
	//determine the parcel temp at each obs point, 
	//and check if pcl t is greater than the obs t.
	var tempP_lo = 0;
	var obsT_lo = 0;
	var pclT_lo = 0;
	var zel = -1;
	for (i=tlinetest[0][0].length-1; i>lfc_index; i--){
		tempP_hi = tlinetest[0][0][i].press;
		if (flag == "MLTv" || flag == "SBTv") {
			obsT_hi = tlinetest[0][0][i].tv;
		} else {
			obsT_hi = tlinetest[0][0][i].temp;
		}
		obsZ_hi = tlinetest[0][0][i].hghtagl;
		pclT_hi = findTC(thetae_lcl, tempP_hi);
		if(pclT_hi > obsT_hi){ 
			obsZ_lo = tlinetest[0][0][i].hghtagl;
			if(i==1){
				//not really any EL, so we assign the pel to the p at the top of the sounding
				pel = tempP_hi;
				tel = pclT_hi
			}else{
				//interpolate the pressure/temperature at the EL
				//slope m = rise over run
				if(obsT_hi - obsT_lo != 0){
					m_obs = (tempP_hi - tempP_lo) / (obsT_hi - obsT_lo);
				}else{
					m_obs = (tempP_hi - tempP_lo) / (0.1);
				}
				m_pcl = (tempP_hi - tempP_lo) / (pclT_hi - pclT_lo);
				//now set up obs lines as ax + by = c
				a = m_obs;
				b = 1;
				c = (m_obs * obsT_hi) - tempP_hi;
				//set up parcel line as dx + ey = f
				d = m_pcl;
				e = 1;
				f = (m_pcl * pclT_hi) - tempP_hi;
				//now some linear algebra
				//find 3 determinates of matrices
				det1 = (a*e)-(b*d);
				det2 = (c*e)-(b*f);
				det3 = (a*f)-(c*d);
				//finally solve for pel and tel
				tel = Math.round(det2/det1*10)/10;
				pel = Math.round(-1*det3/det1);//not sure why the negative sign here, but it appears to work...
				zel = interpVal(pel, tempP_lo, tempP_hi, obsZ_lo, obsZ_hi);
			}

			if (pel == -1 && plfc != -1) {
				pel = plfc;
				zel = zlfc;
			}

			return [plfc, tlfc, zlfc, pel, tel, zel];
		}else{
			if(i <= 0) {
				pel = -1; //never found an equil level
				zel = -1;
			}else{
				tempP_lo = tempP_hi;
				obsT_lo = obsT_hi;
				pclT_lo = pclT_hi;
			}
		}
	}

	if (pel == -1 && plfc != -1) {
		pel = plfc;
		zel = zlfc;
	}

	return [plfc, tlfc, zlfc, pel, tel, zel];
}

function findTC(thetae, xp)
{
	//this function returns tempC for a given P and theta-e
	//it's used to find lfc, el, and cape
	var crit = 0.1;//criteria
	var eq0 = thetae;
	var eq1 = 0;
	var tlev = 10 - ((1000-xp)/10);
	//calc thetae for tlev and p
	for(k=0; k<100; k++){
		eq1 = calcThetaE(xp, tlev, tlev);
		diff = Math.abs(eq0-eq1);
		if(diff < 0.1){//close enough
			break;
		}else if(eq1>eq0){//our try (eq1) is larger than the obs theta-e (eq0)
			tlev = tlev - (diff/10);//so we subtract half the difference from tlev and try again
		}else{//otherwise, we add the difference 
			tlev = tlev + (diff/10);	
		}
	}
	return tlev;
}

function calcThetaE(P,t,dp)
{
	vp=calcVaporPressure(dp);//ambient vapor pressure
	w=calcMixingRatio(vp, P);
	tlclk = tlinetest[0][0][0].lclT+273.15;
	PT = (t + 273.15) * Math.pow(1000/P, 0.2854*(1-(0.00028*w)));
	EPTK = PT * Math.exp(((3.376/tlclk)-0.00254)*w*(1+(0.00081*w)));
	return Math.round(EPTK*10)/10;
}

function calcVaporPressure( temp )
{
	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(temp+273)));
	return vp;
}

function calcLI(t_parc_arr, t_obs_arr)
{
	for(i=0; i<t_parc_arr.length-1; i++) {
		if (tlinetest[0][0][i].press == 500) {
			var calc_li = t_obs_arr[i] - t_parc_arr[i];
			return Math.round(calc_li * 10)/10;
		} else if (tlinetest[0][0][i].press < 500) {
			var calc_li = t500 - interpVal(500, tlinetest[0][0][i].press, tlinetest[0][0][i-1].press, t_parc_arr[i], t_parc_arr[i-1]);
			return Math.round(calc_li * 10)/10;
		}
	}
}

//I developed this function to calc CAPE, and reuse it here.
// It was modified from an algo written by eric smith at csu,\
//I found it in a paper online by schlatter

function calcThetaE(P,t,dp)
{
	//var SP = parseFloat(P) * 1000.0;
	var ST = parseFloat(t) + 273.16;
	var SDP = parseFloat(dp) + 273.16;
	
	vp=calcVaporPressure(dp);//ambient vapor pressure
	w=calcMixingRatio(vp, P);
	//trace("w="+w+" at "+P+"mb");
	Tlcl = (1/(1/(SDP - 56) + Math.log (ST/SDP)/800)) + 56;//calc the temp at LCL
	PT = ST * Math.pow(1000/P, 0.2854*(1-(0.00028*w)));
	EPTK = PT * Math.exp((3.376/Tlcl-0.00254)*w*(1 + 0.00081 * w));
	return Math.round(EPTK*10)/10;
}

function calcZ(pres)
{
	//base = pres / 1013;
	//exp = 287 * .0065 / 9.8;
	base = pres / P0;
	exp = R * .0065 / g;
	temp_z = T0 / .0065 * (1 - Math.pow(base, exp));
	return Math.round(temp_z)
}

function getThickness(z){
	var psfc = tlinetest[0][0][0].press //p at sfc
	if(psfc >= 1000){
		thickness = Math.round(z);
	}else if(psfc < 1000){//sfc pressure is less than 1000, 
	//so extrapolate downward to 1000 mb using std atm lapse rate, 
	//but start at the first point above the sfc rather than the actual sfc.
	//first we actually have to subtract the thickness from the first to second points in the sounding
		sfc_index = 1;
		var t1 = getTv(tlinetest[0][0][sfc_index].temp, tlinetest[0][0][sfc_index].dwpt, tlinetest[0][0][sfc_index].press);
		var t2 = getTv(tlinetest[0][0][sfc_index+1].temp, tlinetest[0][0][sfc_index+1].dwpt, tlinetest[0][0][sfc_index+1].press);
		var Tbar = 273.15 + (t1+t2)/2;
		//second, retrieve the pressure at this level (i) and the next one up (i+1)
		var p1 = tlinetest[0][0][sfc_index].press;
		var p2 = tlinetest[0][0][sfc_index+1].press;
		//last, calculate the layer thickness
		layerz = ((R * Tbar) / g) * Math.log(p1/p2);
		z -= layerz;//subtract layer thickness from current sum (z)
	//now we have to get the thickness from the point above the sfc (t2, p2) down to 1000 mb
	//assume a lapse rate of 0.056 degrees / mb (=std atm from 900-1000 mb)
		var deltap = 1000 - p2;//delta-P from point above the sfc to 1000 mb
		var tvbark = t2 + (deltap * 0.056 / 2) + 273.15; //layer mean Tv (K),.056 degrees/mb from lapse rate of std atm at 900-1000 mb
		//calculate the layer thickness, add it to z
		layerz = ((R * tvbark) / g) * Math.log(1000/tlinetest[0][0][sfc_index+1].press);
		z += layerz;
		thickness = Math.round(z);
	}//station p greater than 1000, already handled in getBRN
}

function getTv(Tc,Tdc,p)
{
	vp = 6.11 * Math.exp(5423 * (1/273 - 1/(Tdc+273)));
	mr = ((0.622*vp)/(p-vp))*1000.0;
	tv = Tc + (mr/6);
	return tv;
}

function convertFiletoJSON(data) {
	sdata = [];
	title_start = data.indexOf("<H2>");
	if (title_start == -1) {
		title_start = data.indexOf("<h2>");
	}
	title_start = title_start+4;
	title_end = data.indexOf("</H2>");
	if (title_end == -1) {
		title_end = data.indexOf("</h2>");
	}
	title = data.slice(title_start, title_end);

	start = data.indexOf("----------------------");
	start = data.indexOf("----------------------", start+77);
	end = data.indexOf("</PRE>");
	if (end == -1) {
		end = data.indexOf("</pre>");
	}

	var info = data.substring(end);
	data = data.substring(start+78, end);

	data_arr = data.split("\n");

	var n = 0;
	var obj = {};

	for (i=0; i < data_arr.length-1; i++) {
		if (data_arr[i].slice(0,7).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.press = Number(data_arr[i].slice(0,7)); 
		}
		if (data_arr[i].slice(7,14).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.hght = Number(data_arr[i].slice(7,14)); 
		}
		if (data_arr[i].slice(14,21).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.temp = Number(data_arr[i].slice(14,21)); 
		}
		if (data_arr[i].slice(21,28).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.dwpt = Number(data_arr[i].slice(21,28)); 
		}
		if (data_arr[i].slice(42,49).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.wdir = Number(data_arr[i].slice(42,49)); 
		}
		if (data_arr[i].slice(49,56).replace(/^\s+/, '').replace(/\s+$/, '') != '') {
			obj.wspd = Number(data_arr[i].slice(49,56)); 
			obj.wspdround = Math.round(Number(data_arr[i].slice(49,56))/5) * 5;
		}
		sdata.push(obj); 
		obj = {};
	}

	lat_start = info.indexOf("latitude:");
	lat_start = lat_start+10;
	lat_end = lat_start+17;
	lat = parseFloat(info.slice(lat_start, lat_end));
	
	long_start = info.indexOf("longitude:");
	long_start = long_start+11;
	long_end = long_start+18;
	long = parseFloat(info.slice(long_start, long_end));

	return sdata;
}

function getLapseRate(tempArr, hghtArr, btmI, btmZ, dZ) {
	var sumLR = 0;
	var n=0;
	for (i=btmI; i<tempArr.length; i++) { 
		if (hghtArr[i]>hghtArr[btmI]+dZ) {
			break;
		}
		t_hi = tempArr[i];
		z_hi = hghtArr[i];
		t_lo = tempArr[i+1];
		z_lo = hghtArr[i+1];
		lr = (t_hi - t_lo) / ((z_hi - z_lo)/1000);
		sumLR += lr;
		n++;
	}
	var lapseRate = -sumLR/n;
	return lapseRate;
}

$(".x .tick").each( function() {
	var tickTran = $(this).attr("transform");
	tickTranX = tickTran.split(",");
	tickTranX = tickTranX[0].split("(");
	tickTranX = tickTranX[1]-14;
	tickTranY = tickTran.split(",");
	tickTranY = tickTranY[1].split(")");
	tickTranY = tickTranY[0]+8;
	$(this).attr("transform", "translate(" + tickTranX + " " + tickTranY + ") rotate(-" + tempSkew + ")");
	

	
});
$(function(){
	$('.draggableWindow').draggable({ 
		cursor: "move",
        cancel: ".drag-cancel"
	});
});
</script>

<div id="editTableWindow" class="draggableWindow" style="display:none;"></div>
</body>
</html>
